diff -Naur mpss-3.8.6/src/mpss-modules/dma/mic_dma_lib.c mpss-modules-3.8.6_el9/dma/mic_dma_lib.c
--- mpss-3.8.6/src/mpss-modules/dma/mic_dma_lib.c	2019-07-02 04:45:06.000000000 +0800
+++ mpss-modules-3.8.6_el9/dma/mic_dma_lib.c	2024-01-03 14:51:57.882283039 +0800
@@ -64,7 +64,6 @@
 #include <mic/micsboxdefine.h>
 
 MODULE_LICENSE("GPL");
-
 #ifdef MIC_IS_EMULATION
 #define DMA_TO		(INT_MAX)
 #define DMA_FENCE_TIMEOUT_CNT (INT_MAX)
@@ -1403,7 +1402,11 @@
 static int
 mic_dma_proc_ring_open(struct inode *inode, struct file *file)
 {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5,14,0))
+        return single_open(file, mic_dma_proc_ring_show, pde_data(inode));
+#else
 	return single_open(file, mic_dma_proc_ring_show, PDE_DATA(inode));
+#endif
 }
 
 static int
@@ -1496,6 +1499,7 @@
 				seq_printf(m," {Type: NOP, 0x%#llx"
 					" %#llx} ",  desc.qwords.qw0,
 						   desc.qwords.qw1);
+                                break; //is it ok?
 			case MEMCOPY:
 				seq_printf(m," {Type: MEMCOPY, SAP:"
 					" 0x%#llx, DAP: %#llx, length: %#llx} ",
@@ -1555,21 +1559,39 @@
 static int
 mic_dma_proc_reg_open(struct inode *inode, struct file *file)
 {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5,14,0))
+        return single_open(file, mic_dma_proc_reg_show, pde_data(inode));
+#else
 	return single_open(file, mic_dma_proc_reg_show, PDE_DATA(inode));
+#endif
 }
-
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5,14,0))
+struct proc_ops micdma_ring_fops = {
+        .proc_open           = mic_dma_proc_ring_open,
+        .proc_read           = seq_read,
+        .proc_lseek         = seq_lseek,
+        .proc_release        = single_release,
+#else
 struct file_operations micdma_ring_fops = {
 	.open		= mic_dma_proc_ring_open,
 	.read		= seq_read,
 	.llseek		= seq_lseek,
         .release 	= single_release,
+#endif
 };
-
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5,14,0))
+struct proc_ops micdma_reg_fops = {
+        .proc_open           = mic_dma_proc_reg_open, 
+        .proc_read           = seq_read,
+        .proc_lseek         = seq_lseek,
+        .proc_release        = single_release,
+#else
 struct file_operations micdma_reg_fops = {
 	.open		= mic_dma_proc_reg_open,
 	.read		= seq_read,
 	.llseek		= seq_lseek,
         .release 	= single_release,
+#endif
 };
 
 static void
diff -Naur mpss-3.8.6/src/mpss-modules/host/acptboot.c mpss-modules-3.8.6_el9/host/acptboot.c
--- mpss-3.8.6/src/mpss-modules/host/acptboot.c	2019-07-02 04:45:06.000000000 +0800
+++ mpss-modules-3.8.6_el9/host/acptboot.c	2024-01-03 14:51:57.882283039 +0800
@@ -41,6 +41,7 @@
 
 #include <scif.h>
 #include <mic_common.h>
+#include "micscif_time.h"
 
 #define ACPT_BACKLOG 120
 #define ACPT_POLL_MS 2000
@@ -61,7 +62,7 @@
 	mic_ctx_t *node_ctx;
 	struct scif_portID data;
 	scif_epd_t conn_epd;
-	struct timespec tod;
+	TIMESPEC tod;
 	int proto;
 	int version;
 	int err;
@@ -101,7 +102,7 @@
 		break;
 
 	case ACPT_REQUEST_TIME:
-		getnstimeofday(&tod);
+		GETNSTIMEOFDAY(&tod);
 		proto = ACPT_TIME_DATA;
 		scif_send(conn_epd, &proto, sizeof(proto), SCIF_SEND_BLOCK);
 		scif_send(conn_epd, &tod, sizeof(tod), SCIF_SEND_BLOCK);
diff -Naur mpss-3.8.6/src/mpss-modules/host/linux.c mpss-modules-3.8.6_el9/host/linux.c
--- mpss-3.8.6/src/mpss-modules/host/linux.c	2019-07-02 04:45:06.000000000 +0800
+++ mpss-modules-3.8.6_el9/host/linux.c	2024-01-03 14:51:57.882283039 +0800
@@ -308,8 +308,13 @@
 	if (mic_msi_enable){
 		for (i = 0; i < MIC_NUM_MSIX_ENTRIES; i ++)
 			bd_info->bi_msix_entries[i].entry = i;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,14,0)
 		err = pci_enable_msix(mic_ctx->bi_pdev, bd_info->bi_msix_entries,
 				      MIC_NUM_MSIX_ENTRIES);
+#else
+		err = pci_enable_msix_exact(mic_ctx->bi_pdev, bd_info->bi_msix_entries,
+				      MIC_NUM_MSIX_ENTRIES);
+#endif
 		if (err == 0 ) {
 			// Only support 1 MSIx for now
 			err = request_irq(bd_info->bi_msix_entries[0].vector,
@@ -337,7 +342,7 @@
 			NULL, "mic%d", mic_ctx->bd_info->bi_ctx.bi_id);
 	err = sysfs_create_group(&mic_ctx->bd_info->bi_sysfsdev->kobj, &bd_attr_group);
 	mic_ctx->sysfs_state = sysfs_get_dirent(mic_ctx->bd_info->bi_sysfsdev->kobj.sd,
-#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,35) && LINUX_VERSION_CODE < KERNEL_VERSION(3,14,0))
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,35) && LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0))
 				NULL,
 #endif
 				"state");
@@ -733,10 +738,12 @@
 	struct file *filp;
 	loff_t filp_size;
 	uint32_t status = 0;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,14,0)
 	mm_segment_t fs = get_fs();
 
 	set_fs(get_ds());
 
+#endif
 	if (!fn || IS_ERR(filp = filp_open(fn, 0, 0))) {
 		status = EINVAL;
 		goto cleanup_fs;
@@ -752,7 +759,9 @@
 cleanup_filp:
 	filp_close(filp, current->files);
 cleanup_fs:
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,14,0)
 	set_fs(fs);
+#endif
 	return status;
 }
 
@@ -765,9 +774,11 @@
 	struct file *filp;
 	loff_t filp_size, pos = 0;
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,14,0)
 	mm_segment_t fs = get_fs();
 	set_fs(get_ds());
 
+#endif
 	if (!fn || IS_ERR(filp = filp_open(fn, 0, 0))) {
 		status = EINVAL;
 		goto cleanup_fs;
@@ -778,7 +789,11 @@
 		goto cleanup_filp;
 	}
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,14,0)
 	c = vfs_read(filp, buffer, filp_size, &pos);
+#else
+	c = kernel_read(filp, buffer, filp_size, &pos);
+#endif
 	if(c != (long)filp_size) {
 		status = -1; //FIXME
 		goto cleanup_filp;
@@ -787,7 +802,9 @@
 cleanup_filp:
 	filp_close(filp, current->files);
 cleanup_fs:
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,14,0)
 	set_fs(fs);
+#endif
 
 	return status;
 }
diff -Naur mpss-3.8.6/src/mpss-modules/host/linvcons.c mpss-modules-3.8.6_el9/host/linvcons.c
--- mpss-3.8.6/src/mpss-modules/host/linvcons.c	2019-07-02 04:45:06.000000000 +0800
+++ mpss-modules-3.8.6_el9/host/linvcons.c	2024-01-03 14:51:57.883283031 +0800
@@ -41,9 +41,17 @@
 static void micvcons_close(struct tty_struct * tty, struct file * filp);
 static int micvcons_write(struct tty_struct * tty, const unsigned char *buf, 
 								int count);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,14,0)
 static int micvcons_write_room(struct tty_struct *tty);
+#else
+static unsigned int micvcons_write_room(struct tty_struct *tty);
+#endif
 static void micvcons_set_termios(struct tty_struct *tty, struct ktermios * old);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,14,0)
 static void micvcons_timeout(unsigned long);
+#else
+static void micvcons_timeout(struct timer_list *t);
+#endif
 static void micvcons_throttle(struct tty_struct *tty);
 static void micvcons_unthrottle(struct tty_struct *tty);
 static void micvcons_wakeup_readbuf(struct work_struct *work);
@@ -62,10 +70,16 @@
 static struct tty_driver *micvcons_tty = NULL;
 static u16 extra_timeout = 0;
 static u8 restart_timer_flag = MICVCONS_TIMER_RESTART;
-static struct timer_list vcons_timer;
-static struct list_head timer_list_head;
 static spinlock_t timer_list_lock;
 
+struct vcons_timer_list {
+    struct timer_list timer;
+    struct list_head  timer_list_head;
+};
+
+static struct vcons_timer_list  vcons_timer;
+
+
 int
 micvcons_create(int num_bds)
 {
@@ -75,7 +89,7 @@
 	char wq_name[14];
 	struct device *dev;
 
-	INIT_LIST_HEAD(&timer_list_head);
+	INIT_LIST_HEAD(&vcons_timer.timer_list_head);
 
 	if (micvcons_tty)
 		goto exit;
@@ -145,16 +159,23 @@
 		}
 		INIT_WORK(&port->dp_wakeup_read_buf, micvcons_wakeup_readbuf);
 	}
-	vcons_timer.function = micvcons_timeout;
-	vcons_timer.data = (unsigned long)(&timer_list_head);
-	init_timer(&vcons_timer);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,14,0)
+	vcons_timer.timer.function = micvcons_timeout;
+	vcons_timer.timer.data = (unsigned long)(&vcons_timer.timer_list_head);
+	init_timer(&vcons_timer.timer);
+#else
+    timer_setup(&vcons_timer.timer, micvcons_timeout, 0);
+#endif
 exit:
 	return ret;
 }
 
 void micvcons_destroy(int num_bds)
 {
-	int bd, ret;
+	int bd;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,14,0)
+        int ret;
+#endif
 	micvcons_port_t *port;
 
 	if (!micvcons_tty)
@@ -164,12 +185,18 @@
 		destroy_workqueue(port->dp_wq);
 		tty_unregister_device(micvcons_tty, bd);
 	}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,14,0)
 	ret = tty_unregister_driver(micvcons_tty);
+#else
+        tty_unregister_driver(micvcons_tty);
+#endif
 	put_tty_driver(micvcons_tty);
 	micvcons_tty = NULL;
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,14,0)
 	if (ret)
 		printk(KERN_ERR "tty unregister_driver failed with code %d\n", ret);
+#endif
 }
 
 static int
@@ -215,10 +242,10 @@
 		if (ret != 0)
 			goto exit_locked;
 		spin_lock(&timer_list_lock);
-		list_add_tail_rcu(&port->list_member, &timer_list_head);
-		if (list_is_singular(&timer_list_head)) {
+		list_add_tail_rcu(&port->list_member, &vcons_timer.timer_list_head);
+		if (list_is_singular(&vcons_timer.timer_list_head)) {
 			restart_timer_flag = MICVCONS_TIMER_RESTART;
-			mod_timer(&vcons_timer, jiffies + 
+			mod_timer(&vcons_timer.timer, jiffies + 
 				msecs_to_jiffies(MICVCONS_SHORT_TIMEOUT));
 		}
 		spin_unlock(&timer_list_lock);
@@ -235,10 +262,10 @@
 {
 	spin_lock(&timer_list_lock);
 	list_del_rcu(&port->list_member);
-	if (list_empty(&timer_list_head)) {
+	if (list_empty(&vcons_timer.timer_list_head)) {
 		restart_timer_flag = MICVCONS_TIMER_SHUTDOWN;
 		spin_unlock(&timer_list_lock);
-		del_timer_sync(&vcons_timer);
+		del_timer_sync(&vcons_timer.timer);
 	} else {
 		spin_unlock(&timer_list_lock);
 	}
@@ -300,8 +327,11 @@
 		micvcons_del_timer_entry(port);
 	return bytes;
 }
-
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,14,0)
 static int
+#else
+static unsigned int
+#endif
 micvcons_write_room(struct tty_struct *tty)
 {
 	micvcons_port_t *port = (micvcons_port_t *)tty->driver_data;
@@ -313,8 +343,11 @@
 	else
 		room = 0;
 	spin_unlock_bh(&port->dp_lock);
-
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,14,0)
 	return room;
+#else
+        return (unsigned int)room;
+#endif
 }
 
 static void
@@ -498,10 +531,30 @@
 		micvcons_del_timer_entry(port);
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,14,0)
 static void
 micvcons_timeout(unsigned long data)
 {
+/* Analysis:
+   data points to a 'struct list_head' 
+   'struct timer_list' has a member 'struct list_head entry'
+
+   list_for_each_entry_rcu(pos, head, member)
+   @pos:    the type * to use as a loop cursor.
+   @head:   the head for your list.
+   @member: the name of the list_head within the struct.
+*/
 	struct list_head *timer_list_ptr = (struct list_head *)data;
+
+#else
+static void
+micvcons_timeout(struct timer_list *t)
+{
+	struct vcons_timer_list *my_vcons_timer = from_timer( my_vcons_timer, t, timer);
+	struct list_head *timer_list_ptr = &my_vcons_timer->timer_list_head;
+
+#endif
+
 	micvcons_port_t *port;
 	u8 console_active = 0;
 	int num_chars_read = 0;
@@ -513,13 +566,12 @@
 			console_active = 1;
 	}
 	rcu_read_unlock();
-
 	spin_lock(&timer_list_lock);
 	if (restart_timer_flag == MICVCONS_TIMER_RESTART) {
 		extra_timeout = (console_active ? 0 :
 				extra_timeout + MICVCONS_SHORT_TIMEOUT);
 		extra_timeout = min(extra_timeout, (u16)MICVCONS_MAX_TIMEOUT);
-		mod_timer(&vcons_timer, jiffies + 
+		mod_timer(&vcons_timer.timer, jiffies + 
 			msecs_to_jiffies(MICVCONS_SHORT_TIMEOUT+extra_timeout));
 	}
 	spin_unlock(&timer_list_lock);
diff -Naur mpss-3.8.6/src/mpss-modules/host/linvnet.c mpss-modules-3.8.6_el9/host/linvnet.c
--- mpss-3.8.6/src/mpss-modules/host/linvnet.c	2019-07-02 04:45:06.000000000 +0800
+++ mpss-modules-3.8.6_el9/host/linvnet.c	2024-01-03 13:13:01.169731255 +0800
@@ -203,7 +203,11 @@
 	.ndo_set_multicast_list = micveth_multicast_list,
 #endif
 	.ndo_set_mac_address	= micveth_set_address,
-	.ndo_change_mtu		= micveth_change_mtu,
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(3,10,0)
+	.ndo_change_mtu_rh74	= micveth_change_mtu,
+#else
+	.ndo_change_mtu			= micveth_change_mtu,
+#endif
 };
 #endif
 
@@ -221,7 +225,11 @@
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,28)
 	dev->netdev_ops = &veth_netdev_ops;
 #endif
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4,14,0)
+	dev->priv_destructor = free_netdev;
+#else
 	dev->destructor = free_netdev;
+#endif
 
 	/* Fill in device structure with ethernet-generic values. */
 	dev->mtu = (MICVETH_MAX_PACKET_SIZE);
@@ -230,8 +238,13 @@
 	random_ether_addr(dev->dev_addr);
 }
 
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4,14,0)
+static int
+micveth_validate(struct nlattr *tb[], struct nlattr *data[], struct netlink_ext_ack *extack)
+#else
 static int
 micveth_validate(struct nlattr *tb[], struct nlattr *data[])
+#endif
 {
 	if (tb[IFLA_ADDRESS]) {
 		if (nla_len(tb[IFLA_ADDRESS]) != ETH_ALEN)
diff -Naur mpss-3.8.6/src/mpss-modules/host/pm_ioctl.c mpss-modules-3.8.6_el9/host/pm_ioctl.c
--- mpss-3.8.6/src/mpss-modules/host/pm_ioctl.c	2019-07-02 04:45:06.000000000 +0800
+++ mpss-modules-3.8.6_el9/host/pm_ioctl.c	2024-01-03 14:51:57.883283031 +0800
@@ -439,7 +439,7 @@
 {
 	/* directory name will be in format micpmXXXXX
 	 * so assuming the name string wont excceed 12 characters */
-	const uint32_t DBG_DIRNAME_LENGTH = 12;
+	#define  DBG_DIRNAME_LENGTH 12
 	char pmdbg_dir_name[DBG_DIRNAME_LENGTH];
 	micpm_ctx_t *micpm_ctx = &mic_ctx->micpm_ctx;
 	struct dentry *mmiodir;
diff -Naur mpss-3.8.6/src/mpss-modules/host/pm_pcstate.c mpss-modules-3.8.6_el9/host/pm_pcstate.c
--- mpss-3.8.6/src/mpss-modules/host/pm_pcstate.c	2019-07-02 04:45:06.000000000 +0800
+++ mpss-modules-3.8.6_el9/host/pm_pcstate.c	2024-01-03 13:13:01.184731142 +0800
@@ -45,20 +45,25 @@
 //few helper functions
 int pm_reg_read(mic_ctx_t *mic_ctx, uint32_t regoffset) {
 	uint32_t regval = 0;
-if (mic_ctx->bi_family == FAMILY_ABR)
-	regval = DBOX_READ(mic_ctx->mmio.va, regoffset);
-else if (mic_ctx->bi_family == FAMILY_KNC)
-	regval = SBOX_READ(mic_ctx->mmio.va, regoffset);
+	if (mic_ctx->bi_family == FAMILY_ABR)
+		regval = DBOX_READ(mic_ctx->mmio.va, regoffset);
+	else {
+		if (mic_ctx->bi_family == FAMILY_KNC)
+			regval = SBOX_READ(mic_ctx->mmio.va, regoffset);
+	}
 
 	return regval;
 }
 
 int pm_reg_write(uint32_t value, mic_ctx_t *mic_ctx, uint32_t regoffset) {
 	int err = 0;
-if (mic_ctx->bi_family == FAMILY_ABR)
-	DBOX_WRITE(value, mic_ctx->mmio.va, regoffset);
-else if (mic_ctx->bi_family == FAMILY_KNC)
-	SBOX_WRITE(value, mic_ctx->mmio.va, regoffset);
+
+	if (mic_ctx->bi_family == FAMILY_ABR)
+		DBOX_WRITE(value, mic_ctx->mmio.va, regoffset);
+	else {
+		 if (mic_ctx->bi_family == FAMILY_KNC)
+			SBOX_WRITE(value, mic_ctx->mmio.va, regoffset);
+	}
 
 	return err;
 }
diff -Naur mpss-3.8.6/src/mpss-modules/host/tools_support.c mpss-modules-3.8.6_el9/host/tools_support.c
--- mpss-3.8.6/src/mpss-modules/host/tools_support.c	2019-07-02 04:45:06.000000000 +0800
+++ mpss-modules-3.8.6_el9/host/tools_support.c	2024-01-03 14:51:57.883283031 +0800
@@ -64,7 +64,12 @@
 		for (j = 0; j < nf_pages; j++) {
 			if (pages[j]) {
 				SetPageDirty(pages[j]);
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4,14,0)
+				put_page(pages[j]);
+#else
 				page_cache_release(pages[j]);
+#endif
+
 			}
 		}
 		kfree(pages);
@@ -86,12 +91,27 @@
 		return status;
 
 	}
-
+#ifndef MMAP_LOCK_INITIALIZER
 	// pin the user pages; use semaphores on linux for doing the same
 	down_read(&current->mm->mmap_sem);
+#else
+        mmap_read_lock(current->mm);
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,14,0)
+        *nf_pages = (int32_t)get_user_pages_remote(current->mm, (uint64_t)data,
+                          nr_pages, PROT_WRITE, pages, NULL, NULL);
+#elif LINUX_VERSION_CODE > KERNEL_VERSION(4,14,0)
+	*nf_pages = (int32_t)get_user_pages_remote(current, current->mm, (uint64_t)data,
+			  nr_pages, PROT_WRITE, pages, NULL, NULL);
+#else
 	*nf_pages = (int32_t)get_user_pages(current, current->mm, (uint64_t)data,
 			  nr_pages, PROT_WRITE, 1, pages, NULL);
+#endif
+#ifndef MMAP_LOCK_INITIALIZER
 	up_read(&current->mm->mmap_sem);
+#else
+        mmap_read_unlock(current->mm);
+#endif
 
 	// compare if the no of final pages is equal to no of requested pages
 	if ((*nf_pages) < nr_pages) {
@@ -115,7 +135,7 @@
 	sbox_scratch2_reg_t scratch2reg = {0};
 	uint32_t ret = 0;
 	void *src;
-	struct timeval t;
+	ktime_t start_time;
 	struct flash_stat *statbuf = NULL;
 	uint64_t temp;
 	uint32_t i = 0;
@@ -303,14 +323,18 @@
 			status = -EINVAL;
 			goto exit;
 		}
-
+        FALLTHROUGH;
 	case RAS_CMD:
+
 	case RAS_CMD_INJECT_REPAIR:
+        /* FALLTHRU */
 	case RAS_CMD_ECC_DISABLE:
+        /* FALLTHRU */
 	case RAS_CMD_ECC_ENABLE:
+        /* FALLTHRU */
 	case RAS_CMD_EXIT:
-		do_gettimeofday(&t);
-		SBOX_WRITE(t.tv_sec, mmio_va, SBOX_SCRATCH3);
+		start_time = ktime_get();
+		SBOX_WRITE(ktime_to_ns(start_time)/1000000000, mmio_va, SBOX_SCRATCH3);
 		scratch1reg.bits.command = type;
 		SBOX_WRITE(scratch1reg.value, mmio_va, SBOX_SCRATCH1);
 
diff -Naur mpss-3.8.6/src/mpss-modules/host/uos_download.c mpss-modules-3.8.6_el9/host/uos_download.c
--- mpss-3.8.6/src/mpss-modules/host/uos_download.c	2019-07-02 04:45:06.000000000 +0800
+++ mpss-modules-3.8.6_el9/host/uos_download.c	2024-01-03 14:51:57.883283031 +0800
@@ -43,6 +43,7 @@
 #include "mic/mic_virtio.h"
 #include <linux/proc_fs.h>
 #include "mic/micveth.h"
+#include "micscif_time.h"
 
 
 #define APERTURE_SEGMENT_SIZE   ((1) * 1024 * 1024 * 1024ULL)
@@ -121,22 +122,22 @@
 	 */
 	/* Need to implement the monotonic/irqsave logic for windows */
 	unsigned long flags;
-	struct timespec ts1, ts2;
+	TIMESPEC ts1, ts2;
 	int64_t mono_ns;
 	int i = 0;
 	do {
 		local_irq_save(flags);
 		cnt1 = etc_read(mic_ctx->mmio.va);
-		getrawmonotonic(&ts1);
+		GETRAWMONOTONIC(&ts1);
 		local_irq_restore(flags);
 		mdelay(TIME_DELAY_IN_SEC * 1000);
 		local_irq_save(flags);
 		cnt2 = etc_read(mic_ctx->mmio.va);
-		getrawmonotonic(&ts2);
+		GETRAWMONOTONIC(&ts2);
 		local_irq_restore(flags);
 		etc_cnt2 = cnt2 - cnt1;
-		ts2 = timespec_sub(ts2, ts1);
-		mono_ns = timespec_to_ns(&ts2);
+		ts2 = TIMESPEC_SUB(ts2, ts1);
+		mono_ns = TIMESPEC_TO_NS(&ts2);
 		/* Recalculate etc_cnt2 based on getrawmonotonic */
 		etc_cnt2 = (etc_cnt2 * TIME_DELAY_IN_SEC * 1000 * 1000 * 1000) / mono_ns;
 		deltaf = ( ETC_CLK_FREQ * (etc_cnt2 - etc_cnt1)) / etc_cnt1;
@@ -811,10 +812,15 @@
 }
 
 /* Perform hardware reset of the device */
-void
-reset_timer(unsigned long arg)
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4,14,0)
+void reset_timer(struct timer_list *t)
+{
+	mic_ctx_t *mic_ctx = from_timer(mic_ctx, t, boot_timer);
+#else
+void reset_timer(unsigned long arg)
 {
 	mic_ctx_t *mic_ctx = (mic_ctx_t *)arg;
+#endif
 	uint32_t scratch2 = 0;
 	uint32_t postcode = mic_getpostcode(mic_ctx);
 
@@ -865,8 +871,12 @@
 		return;
 	}
 
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4,14,0)
+	timer_setup(&mic_ctx->boot_timer, reset_timer, 0);
+#else
 	mic_ctx->boot_timer.function = reset_timer;
 	mic_ctx->boot_timer.data = (unsigned long)mic_ctx;
+#endif
 	mic_ctx->boot_timer.expires = jiffies + HZ;
 
 	add_timer(&mic_ctx->boot_timer);
@@ -875,8 +885,12 @@
 void
 adapter_wait_reset(mic_ctx_t *mic_ctx)
 {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4,14,0)
+	timer_setup(&mic_ctx->boot_timer, reset_timer, 0);
+#else
 	mic_ctx->boot_timer.function = reset_timer;
 	mic_ctx->boot_timer.data = (unsigned long)mic_ctx;
+#endif
 	mic_ctx->boot_timer.expires = jiffies + HZ;
 	mic_ctx->boot_start = jiffies;
 
@@ -1050,10 +1064,15 @@
 
 #define MIC_MAX_BOOT_TIME 180	// Maximum number of seconds to wait for boot to complete
 
-static void
-online_timer(unsigned long arg)
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4,14,0)
+static void online_timer(struct timer_list *t)
+{
+	mic_ctx_t *mic_ctx = from_timer(mic_ctx, t, boot_timer);
+#else
+static void online_timer(unsigned long arg)
 {
 	mic_ctx_t *mic_ctx = (mic_ctx_t *)arg;
+#endif
 	uint64_t delay = (jiffies - mic_ctx->boot_start) / HZ;
 
 	if (mic_ctx->state == MIC_ONLINE)
@@ -1065,19 +1084,29 @@
 		return;
 	}
 
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4,14,0)
+	timer_setup(&mic_ctx->boot_timer, online_timer, 0);
+#else
 	mic_ctx->boot_timer.function = online_timer;
 	mic_ctx->boot_timer.data = (unsigned long)mic_ctx;
+#endif
 	mic_ctx->boot_timer.expires = jiffies + HZ;
+
 	add_timer(&mic_ctx->boot_timer);
 
 	if (!(delay % 5))
 		printk("Waiting for MIC %d boot %lld\n", mic_ctx->bi_id, delay);
 }
 
-static void
-boot_timer(unsigned long arg)
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4,14,0)
+static void boot_timer(struct timer_list *t)
+{
+	mic_ctx_t *mic_ctx = from_timer(mic_ctx, t, boot_timer);
+#else
+static void boot_timer(unsigned long arg)
 {
 	mic_ctx_t *mic_ctx = (mic_ctx_t *)arg;
+#endif
 	struct micvnet_info *vnet_info = (struct micvnet_info *) mic_ctx->bi_vethinfo;
 	uint64_t delay = (jiffies - mic_ctx->boot_start) / HZ;
 	bool timer_restart = false;
@@ -1102,17 +1131,26 @@
 		timer_restart = (mic_ctx->state != MIC_ONLINE)? true: false;
 
 	if (timer_restart) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4,14,0)
+		timer_setup(&mic_ctx->boot_timer, boot_timer, 0);
+#else
 		mic_ctx->boot_timer.function = boot_timer;
 		mic_ctx->boot_timer.data = (unsigned long)mic_ctx;
+#endif
 		mic_ctx->boot_timer.expires = jiffies + HZ;
 
 		add_timer(&mic_ctx->boot_timer);
 		return;
 	}
 
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4,14,0)
+	timer_setup(&mic_ctx->boot_timer, online_timer, 0);
+#else
 	mic_ctx->boot_timer.function = online_timer;
 	mic_ctx->boot_timer.data = (unsigned long)mic_ctx;
+#endif
 	mic_ctx->boot_timer.expires = jiffies + HZ;
+
 	add_timer(&mic_ctx->boot_timer);
 
 	printk("MIC %d Network link is up\n", mic_ctx->bi_id);
@@ -1166,8 +1204,12 @@
 int
 adapter_post_boot_device(mic_ctx_t *mic_ctx)
 {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4,14,0)
+	timer_setup(&mic_ctx->boot_timer, boot_timer, 0);
+#else
 	mic_ctx->boot_timer.function = boot_timer;
 	mic_ctx->boot_timer.data = (unsigned long)mic_ctx;
+#endif
 	mic_ctx->boot_timer.expires = jiffies + HZ;
 	mic_ctx->boot_start = jiffies;
 
@@ -1242,13 +1284,21 @@
 {
 	return single_open(file, ramoops_proc_show, NULL);
 }
-
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5,14,0))
+struct proc_ops ramoops_proc_fops = {
+        .proc_open           = ramoops_proc_open,
+        .proc_read           = seq_read,
+        .proc_lseek         = seq_lseek,
+        .proc_release        = single_release,
+};
+#else
 struct file_operations ramoops_proc_fops = {
 	.open		= ramoops_proc_open,
 	.read		= seq_read,
 	.llseek		= seq_lseek,
         .release 	= single_release,
 };
+#endif
 
 #else // LINUX VERSION
 static int
@@ -1497,7 +1547,9 @@
 	mutex_init (&mic_ctx->state_lock);
 	init_waitqueue_head(&mic_ctx->resetwq);
 	init_waitqueue_head(&mic_ctx->ioremapwq);
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(4,14,0)
 	init_timer(&mic_ctx->boot_timer);
+#endif
 	if (!(mic_ctx->resetworkq = __mic_create_singlethread_workqueue("RESET WORK")))
 		return -ENOMEM;
 	if (!(mic_ctx->ioremapworkq = __mic_create_singlethread_workqueue("IOREMAP_WORK"))) {
@@ -1511,8 +1563,11 @@
 
 	device_id = mic_ctx->bi_pdev->device;
 	mic_ctx->bi_family = get_product_family(device_id);
-
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,14,0)
 	if ((mic_ctx->mmio.va = ioremap_nocache(mic_ctx->mmio.pa, 
+#else
+        if ((mic_ctx->mmio.va = ioremap(mic_ctx->mmio.pa,
+#endif
 						mic_ctx->mmio.len)) == NULL) {
 		printk("mic %d: failed to map mmio space\n", mic_ctx->bi_id);
 		err = -ENOMEM;
diff -Naur mpss-3.8.6/src/mpss-modules/host/vhost/mic_blk.c mpss-modules-3.8.6_el9/host/vhost/mic_blk.c
--- mpss-3.8.6/src/mpss-modules/host/vhost/mic_blk.c	2019-07-02 04:45:06.000000000 +0800
+++ mpss-modules-3.8.6_el9/host/vhost/mic_blk.c	2024-01-03 13:13:01.172731232 +0800
@@ -42,7 +42,9 @@
 #include "mic/mic_virtio.h"
 
 #define SECTOR_SHIFT		9
+#ifndef SECTOR_SIZE
 #define SECTOR_SIZE		(1UL << SECTOR_SHIFT)
+#endif
 #define VIRTIO_BLK_QUEUE_SIZE		128
 #define DISK_SEG_MAX			(VIRTIO_BLK_QUEUE_SIZE - 2)
 
@@ -80,6 +82,50 @@
 static LIST_HEAD(write_queue);
 static LIST_HEAD(read_queue);
 
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,14,0))
+
+/* replacement functions for vfs_readv,vfs_writev which were removed from kernel 4+ */
+
+
+ssize_t vfs_readv(struct file *file, const struct iovec __user *vec,
+          unsigned long vlen, loff_t *pos, rwf_t flags)
+{
+    struct iovec iovstack[UIO_FASTIOV];
+    struct iovec *iov = iovstack;
+    struct iov_iter iter;
+    ssize_t ret; 
+
+    ret = import_iovec(READ, vec, vlen, ARRAY_SIZE(iovstack), &iov, &iter);
+    if (ret >= 0) { 
+        ret = vfs_iter_read(file, &iter, pos, flags);
+        kfree(iov);
+    }    
+
+    return ret; 
+}
+
+static ssize_t vfs_writev(struct file *file, const struct iovec __user *vec,
+           unsigned long vlen, loff_t *pos, rwf_t flags)
+{
+    struct iovec iovstack[UIO_FASTIOV];
+    struct iovec *iov = iovstack;
+    struct iov_iter iter;
+    ssize_t ret;
+
+    ret = import_iovec(WRITE, vec, vlen, ARRAY_SIZE(iovstack), &iov, &iter);
+    if (ret >= 0) {
+        file_start_write(file);
+        ret = vfs_iter_write(file, &iter, pos, flags);
+        file_end_write(file);
+        kfree(iov);
+    }
+    return ret;
+}
+
+#endif
+
+
 static void
 cleanup_vblk_workqueue(struct vhost_blk_io *vbio, struct vhost_virtqueue *vq)
 {
@@ -153,12 +199,20 @@
 	  for (iov = vbio->iov; iov < &vbio->iov[vbio->nvecs]; iov++) {
 		iov->iov_base = mic_addr_in_host(aper_va, iov->iov_base);
 	  }
-		ret = vfs_writev(vbio->file, vbio->iov, vbio->nvecs, &pos);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,14,0))
+        ret = vfs_writev(vbio->file, vbio->iov, vbio->nvecs, &pos, 0);
+#else
+        ret = vfs_writev(vbio->file, vbio->iov, vbio->nvecs, &pos);
+#endif
 	} else {
 	  for (iov = vbio->iov; iov < &vbio->iov[vbio->nvecs]; iov++) {
 		iov->iov_base = mic_addr_in_host(aper_va, iov->iov_base);
 	  }
-		ret = vfs_readv(vbio->file, vbio->iov, vbio->nvecs, &pos);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,14,0))
+        ret = vfs_readv(vbio->file, vbio->iov, vbio->nvecs, &pos, 0);
+#else
+        ret = vfs_readv(vbio->file, vbio->iov, vbio->nvecs, &pos);
+#endif
 	}
 	status = (ret < 0) ? VIRTIO_BLK_S_IOERR : VIRTIO_BLK_S_OK;
 	if (vbio->head != -1) {
@@ -475,7 +529,9 @@
 	writel(DISK_SEG_MAX, &vb_shared->blk_config.seg_max);
 	writel(SECTOR_SIZE, &vb_shared->blk_config.blk_size);
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,9,0))
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,14,0))
+	ret = vfs_getattr(&vblk->virtblk_file->f_path, &stat, STATX_BASIC_STATS, AT_STATX_SYNC_AS_STAT);
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(3,9,0))
 	ret = vfs_getattr(&vblk->virtblk_file->f_path, &stat);
 #else
 	ret = vfs_getattr(vblk->virtblk_file->f_path.mnt,
diff -Naur mpss-3.8.6/src/mpss-modules/host/vhost/mic_vhost.c mpss-modules-3.8.6_el9/host/vhost/mic_vhost.c
--- mpss-3.8.6/src/mpss-modules/host/vhost/mic_vhost.c	2019-07-02 04:45:06.000000000 +0800
+++ mpss-modules-3.8.6_el9/host/vhost/mic_vhost.c	2024-01-03 14:51:57.884283023 +0800
@@ -72,11 +72,17 @@
 	add_wait_queue(wqh, &poll->wait);
 }
 
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(4,14,0))
+static int vhost_poll_wakeup(wait_queue_entry_t *wait, unsigned mode, int sync,
+			     void *key)
+#else
 static int vhost_poll_wakeup(wait_queue_t *wait, unsigned mode, int sync,
 			     void *key)
+#endif
 {
 	struct vhost_poll *poll = container_of(wait, struct vhost_poll, wait);
 
+	printk("vhost_poll_wakeup\n");
 	if (!((unsigned long)key & poll->mask))
 		return 0;
 
@@ -397,7 +403,9 @@
 	return 0;
 }
 #endif
-
+#ifndef read_barrier_depends
+#define read_barrier_depends() do { } while (0)
+#endif
 /* Each buffer in the virtqueues is actually a chain of descriptors.  This
  * function returns the next descriptor in the chain,
  * or -1U if we're at the end. */
diff -Naur mpss-3.8.6/src/mpss-modules/host/vhost/vhost.h mpss-modules-3.8.6_el9/host/vhost/vhost.h
--- mpss-3.8.6/src/mpss-modules/host/vhost/vhost.h	2019-07-02 04:45:06.000000000 +0800
+++ mpss-modules-3.8.6_el9/host/vhost/vhost.h	2024-01-03 13:13:01.172731232 +0800
@@ -20,6 +20,7 @@
 #include <linux/virtio_config.h>
 #include <linux/virtio_ring.h>
 #include <asm/atomic.h>
+#include <asm/barrier.h>
 
 /* This is for zerocopy, used buffer len is set to 1 when lower device DMA
  * done */
@@ -45,7 +46,11 @@
 struct vhost_poll {
 	poll_table                table;
 	wait_queue_head_t        *wqh;
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(4,14,0))
+	wait_queue_entry_t        wait;
+#else
 	wait_queue_t              wait;
+#endif
 	struct vhost_work	  work;
 	unsigned long		  mask;
 	struct vhost_dev	 *dev;
@@ -240,6 +245,10 @@
 
 static inline int vhost_has_feature(struct vhost_dev *dev, int bit)
 {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,14,0))
+	unsigned acked_features = smp_load_acquire(&(dev->acked_features));
+#else
+
 #ifdef RHEL_RELEASE_CODE
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0))
 	unsigned acked_features = rcu_dereference_index_check(dev->acked_features, rcu_read_lock_held());
@@ -253,6 +262,8 @@
 	unsigned acked_features = __rcu_dereference_index_check(dev->acked_features, rcu_read_lock_held());
 #endif
 #endif
+
+#endif
 	return acked_features & (1 << bit);
 }
 
diff -Naur mpss-3.8.6/src/mpss-modules/host/vmcore.c mpss-modules-3.8.6_el9/host/vmcore.c
--- mpss-3.8.6/src/mpss-modules/host/vmcore.c	2019-07-02 04:45:06.000000000 +0800
+++ mpss-modules-3.8.6_el9/host/vmcore.c	2024-01-03 14:51:57.884283023 +0800
@@ -50,7 +50,6 @@
 #include <linux/elfcore.h>
 #include <linux/slab.h>
 #include <linux/highmem.h>
-#include <linux/bootmem.h>
 #include <linux/init.h>
 #include <linux/crash_dump.h>
 #include <linux/list.h>
@@ -161,7 +160,7 @@
 }
 
 /* Reads a page from the oldmem device from given offset. */
-static ssize_t read_from_oldmem(mic_ctx_t *mic_ctx,
+static ssize_t mic_read_from_oldmem(mic_ctx_t *mic_ctx,
 				char *buf, size_t count,
 				u64 *ppos, int userbuf)
 {
@@ -228,7 +227,11 @@
 	struct vmcore *curr_m = NULL;
 	struct inode *inode = file->f_path.dentry->d_inode;
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0))
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5,14,0))
+        mic_ctx_t *mic_ctx = pde_data(inode);
+#else
 	mic_ctx_t *mic_ctx = PDE_DATA(inode);
+#endif
 #else
 	struct proc_dir_entry *entry = PDE(inode);
 	mic_ctx_t *mic_ctx = entry->data;
@@ -270,7 +273,7 @@
 		tsz = nr_bytes;
 
 	while (buflen) {
-		tmp = read_from_oldmem(mic_ctx,buffer, tsz, &start, 1);
+		tmp = mic_read_from_oldmem(mic_ctx,buffer, tsz, &start, 1);
 		if (tmp < 0)
 			return tmp;
 		buflen -= tsz;
@@ -293,10 +296,15 @@
 	}
 	return acc;
 }
-
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5,14,0))
+static const struct proc_ops proc_vmcore_operations = {
+        .proc_read           = read_vmcore,
+};
+#else
 static const struct file_operations proc_vmcore_operations = {
 	.read		= read_vmcore,
 };
+#endif
 
 static struct vmcore* get_new_element(void)
 {
@@ -364,7 +372,7 @@
 		notes_section = kmalloc(max_sz, GFP_KERNEL);
 		if (!notes_section)
 			return -ENOMEM;
-		rc = read_from_oldmem(mic_ctx, notes_section, max_sz, &offset, 0);
+		rc = mic_read_from_oldmem(mic_ctx, notes_section, max_sz, &offset, 0);
 		if (rc < 0) {
 			kfree(notes_section);
 			return rc;
@@ -446,7 +454,7 @@
 		notes_section = kmalloc(max_sz, GFP_KERNEL);
 		if (!notes_section)
 			return -ENOMEM;
-		rc = read_from_oldmem(mic_ctx, notes_section, max_sz, &offset, 0);
+		rc = mic_read_from_oldmem(mic_ctx, notes_section, max_sz, &offset, 0);
 		if (rc < 0) {
 			kfree(notes_section);
 			return rc;
@@ -626,7 +634,7 @@
 	addr = elfcorehdr_addr;
 
 	/* Read Elf header */
-	rc = read_from_oldmem(mic_ctx, (char*)&ehdr, sizeof(Elf64_Ehdr), &addr, 0);
+	rc = mic_read_from_oldmem(mic_ctx, (char*)&ehdr, sizeof(Elf64_Ehdr), &addr, 0);
 	if (rc < 0)
 		return rc;
 
@@ -660,7 +668,7 @@
 	if (!mic_ctx->elfcorebuf)
 		return -ENOMEM;
 	addr = elfcorehdr_addr;
-	rc = read_from_oldmem(mic_ctx, mic_ctx->elfcorebuf, mic_ctx->elfcorebuf_sz, &addr, 0);
+	rc = mic_read_from_oldmem(mic_ctx, mic_ctx->elfcorebuf, mic_ctx->elfcorebuf_sz, &addr, 0);
 	if (rc < 0) {
 		kfree(mic_ctx->elfcorebuf);
 		mic_ctx->elfcorebuf = NULL;
@@ -694,7 +702,7 @@
 	addr = elfcorehdr_addr;
 
 	/* Read Elf header */
-	rc = read_from_oldmem(mic_ctx, (char*)&ehdr, sizeof(Elf32_Ehdr), &addr, 0);
+	rc = mic_read_from_oldmem(mic_ctx, (char*)&ehdr, sizeof(Elf32_Ehdr), &addr, 0);
 	if (rc < 0)
 		return rc;
 
@@ -720,7 +728,7 @@
 	if (!mic_ctx->elfcorebuf)
 		return -ENOMEM;
 	addr = elfcorehdr_addr;
-	rc = read_from_oldmem(mic_ctx, mic_ctx->elfcorebuf, mic_ctx->elfcorebuf_sz, &addr, 0);
+	rc = mic_read_from_oldmem(mic_ctx, mic_ctx->elfcorebuf, mic_ctx->elfcorebuf_sz, &addr, 0);
 	if (rc < 0) {
 		kfree(mic_ctx->elfcorebuf);
 		mic_ctx->elfcorebuf = NULL;
@@ -752,7 +760,7 @@
 	int rc=0;
 
 	addr = elfcorehdr_addr;
-	rc = read_from_oldmem(mic_ctx, e_ident, EI_NIDENT, &addr, 0);
+	rc = mic_read_from_oldmem(mic_ctx, e_ident, EI_NIDENT, &addr, 0);
 	if (rc < 0)
 		return rc;
 	if (memcmp(e_ident, ELFMAG, SELFMAG) != 0) {
diff -Naur mpss-3.8.6/src/mpss-modules/include/mic/micscif_nm.h mpss-modules-3.8.6_el9/include/mic/micscif_nm.h
--- mpss-3.8.6/src/mpss-modules/include/mic/micscif_nm.h	2019-07-02 04:45:06.000000000 +0800
+++ mpss-modules-3.8.6_el9/include/mic/micscif_nm.h	2024-01-03 14:51:57.884283023 +0800
@@ -100,7 +100,7 @@
 			SCIFDEV_INIT == dev->sd_state)
 			goto bail_out;
 		if (test_bit(SCIF_NODE_MAGIC_BIT, 
-			&dev->scif_ref_cnt.counter)) {
+			(unsigned long *)&dev->scif_ref_cnt.counter)) {
 			/* Notify host that the remote node must be woken */
 			struct nodemsg notif_msg;
 
@@ -126,7 +126,7 @@
 			if (dev->sd_wait_status == OP_COMPLETED) {
 				dev->sd_state = SCIFDEV_RUNNING;
 				clear_bit(SCIF_NODE_MAGIC_BIT, 
-					&dev->scif_ref_cnt.counter);
+					(unsigned long *)&dev->scif_ref_cnt.counter);
 			}
 		}
 		/* The ref count was not added if the node was idle. */
diff -Naur mpss-3.8.6/src/mpss-modules/include/mic/micscif_rma.h mpss-modules-3.8.6_el9/include/mic/micscif_rma.h
--- mpss-3.8.6/src/mpss-modules/include/mic/micscif_rma.h	2019-07-02 04:45:06.000000000 +0800
+++ mpss-modules-3.8.6_el9/include/mic/micscif_rma.h	2024-01-03 14:51:57.884283023 +0800
@@ -66,6 +66,7 @@
 #include <linux/semaphore.h>
 #include <linux/kthread.h>
 #include <linux/sched.h>
+#include <linux/sched/signal.h>
 #include <linux/delay.h>
 #include <linux/wait.h>
 #include <asm/bug.h>
@@ -915,18 +916,32 @@
 {
 	if (mm && nr_pages && mic_ulimit_check) {
 		if (try_lock) {
+#ifndef MMAP_LOCK_INITIALIZER
 			if (!down_write_trylock(&mm->mmap_sem)) {
+#else
+                        if (!mmap_write_trylock(mm)) {
+#endif
 				return -1;
 			}
 		} else {
+#ifndef MMAP_LOCK_INITIALIZER
 			down_write(&mm->mmap_sem);
+#else
+                        mmap_write_lock(mm);
+#endif
 		}
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 1, 0))
+#if (defined(RHEL_RELEASE_CODE) && (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)))
+		mm->pinned_vm.counter -= nr_pages;
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 1, 0))
 		mm->pinned_vm -= nr_pages;
 #else
 		mm->locked_vm -= nr_pages;
 #endif
+#ifndef MMAP_LOCK_INITIALIZER
 		up_write(&mm->mmap_sem);
+#else
+                mmap_write_unlock(mm);
+#endif
 	}
 	return 0;
 }
@@ -937,7 +952,9 @@
 	if (mm && mic_ulimit_check && nr_pages) {
 		unsigned long locked, lock_limit;
 		locked = nr_pages;
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 1, 0))
+#if (defined(RHEL_RELEASE_CODE) && (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)))
+		locked += mm->pinned_vm.counter;
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 1, 0))
 		locked += mm->pinned_vm;
 #else
 		locked += mm->locked_vm;
@@ -948,7 +965,9 @@
 				    locked, lock_limit);
 			return -ENOMEM;
 		} else {
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 1, 0))
+#if (defined(RHEL_RELEASE_CODE) && (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)))
+			mm->pinned_vm.counter = locked;
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 1, 0))
 			mm->pinned_vm = locked;
 #else
 			mm->locked_vm = locked;
diff -Naur mpss-3.8.6/src/mpss-modules/include/mic_common.h mpss-modules-3.8.6_el9/include/mic_common.h
--- mpss-3.8.6/src/mpss-modules/include/mic_common.h	2019-07-02 04:45:06.000000000 +0800
+++ mpss-modules-3.8.6_el9/include/mic_common.h	2024-01-03 14:51:57.885283014 +0800
@@ -87,6 +87,12 @@
 #include <mic/micveth_common.h>
 #include <mic/micscif_nm.h>
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5,14,0))
+    #define FALLTHROUGH __attribute__ ((__fallthrough__));
+#else
+    #define FALLTHROUGH
+#endif
+
 #define GET_MAX(a, b)	( ((a) > (b)) ? (a) : (b) )
 #define GET_MIN(a, b)	( ((a) < (b)) ? (a) : (b) )
 
@@ -274,6 +280,17 @@
 	MIC_INVALID
 } MIC_STATUS;
 
+/* Values used for Mic system states.
+   Note that these states *differ* from the Linux kernel 4+ system states
+ */
+typedef enum mic_system_states {
+    MIC_SYSTEM_BOOTING,
+    MIC_SYSTEM_RUNNING,
+    MIC_SYSTEM_HALT,
+    MIC_SYSTEM_POWER_OFF,
+    MIC_SYSTEM_RESTART,
+} MIC_SYSTEM_STATE;
+
 typedef enum _product_platform_t
 {
 	PLATFORM_SILICON = 0,
@@ -415,7 +432,7 @@
 	product_family_t	bi_family;
 	struct board_info	*bd_info;
 	sysfs_info_t		sysfs_info;
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,14,0))
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0))
 	struct kernfs_node	*sysfs_state;
 #else
 	struct sysfs_dirent	*sysfs_state;
diff -Naur mpss-3.8.6/src/mpss-modules/include/micscif_time.h mpss-modules-3.8.6_el9/include/micscif_time.h
--- mpss-3.8.6/src/mpss-modules/include/micscif_time.h	1970-01-01 08:00:00.000000000 +0800
+++ mpss-modules-3.8.6_el9/include/micscif_time.h	2024-01-03 14:51:57.885283014 +0800
@@ -0,0 +1,25 @@
+#pragma once
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5,14,0))
+#define TIMESPEC struct timespec
+#define KTIME_GET_TS ktime_get_ts
+#define TIMESPEC_VALID timespec_valid
+#define TIMESPEC_TO_KTIME timespec_to_ktime
+#define TIMESPEC_SUB timespec_sub
+#define SET_NORMALIZED_TIMESPEC set_normalized_timespec
+#define TIMESPEC_MAX TIME_T_MAX
+#define GETNSTIMEOFDAY getnstimeofday
+#define GETRAWMONOTONIC getrawmonotonic
+#define TIMESPEC_TO_NS timespec_to_ns
+#else
+#define TIMESPEC struct timespec64
+#define KTIME_GET_TS ktime_get_ts64
+#define TIMESPEC_VALID timespec64_valid
+#define TIMESPEC_TO_KTIME timespec64_to_ktime
+#define TIMESPEC_SUB timespec64_sub
+#define SET_NORMALIZED_TIMESPEC set_normalized_timespec64
+#define TIMESPEC_MAX TIME64_MAX
+#define GETNSTIMEOFDAY ktime_get_real_ts64
+#define GETRAWMONOTONIC ktime_get_raw_ts64
+#define TIMESPEC_TO_NS timespec64_to_ns
+#endif
+
diff -Naur mpss-3.8.6/src/mpss-modules/include/scif.h mpss-modules-3.8.6_el9/include/scif.h
--- mpss-3.8.6/src/mpss-modules/include/scif.h	2019-07-02 04:45:06.000000000 +0800
+++ mpss-modules-3.8.6_el9/include/scif.h	2024-01-03 13:13:01.185731134 +0800
@@ -45,6 +45,7 @@
 #include <linux/errno.h>
 #include <linux/poll.h>
 #include <linux/pci.h>
+#include <linux/sched/mm.h>
 
 #ifdef __cplusplus
 extern "C" {
diff -Naur mpss-3.8.6/src/mpss-modules/micscif/micscif_api.c mpss-modules-3.8.6_el9/micscif/micscif_api.c
--- mpss-3.8.6/src/mpss-modules/micscif/micscif_api.c	2019-07-02 04:45:06.000000000 +0800
+++ mpss-modules-3.8.6_el9/micscif/micscif_api.c	2024-01-03 14:51:57.885283014 +0800
@@ -167,6 +167,7 @@
 	switch (oldstate) {
 	case SCIFEP_ZOMBIE:
 		BUG_ON(SCIFEP_ZOMBIE == oldstate);
+		FALLTHROUGH;
 	case SCIFEP_CLOSED:
 	case SCIFEP_DISCONNECTED:
 		spin_unlock_irqrestore(&ep->lock, sflags);
@@ -597,6 +598,7 @@
 	switch (ep->state) {
 	case SCIFEP_ZOMBIE:
 		BUG_ON(SCIFEP_ZOMBIE == ep->state);
+		FALLTHROUGH;
 	case SCIFEP_CLOSED:
 	case SCIFEP_CLOSING:
 	case SCIFEP_CLLISTEN:
@@ -902,7 +904,7 @@
 	switch (ep->state) {
 	case SCIFEP_ZOMBIE:
 		BUG_ON(SCIFEP_ZOMBIE == ep->state);
-
+		FALLTHROUGH;
 	case SCIFEP_CLOSED:
 	case SCIFEP_CLOSING:
 		err = -EINVAL;
@@ -942,7 +944,7 @@
 			ep->port.node = ms_info.mi_nodeid;
 			ep->conn_async_state = ASYNC_CONN_IDLE;
 		}
-		/* Fall through */
+		FALLTHROUGH;
 	case SCIFEP_BOUND:
 		/*
 		 * If a non-blocking connect has been already initiated (conn_async_state
@@ -1971,16 +1973,38 @@
 		prot |= SCIF_PROT_WRITE;
 retry:
 		mm = current->mm;
+#ifndef MMAP_LOCK_INITIALIZER
 		down_write(&mm->mmap_sem);
+#else
+                mmap_write_lock(mm);
+#endif
 		if (ulimit) {
 			err = __scif_check_inc_pinned_vm(mm, nr_pages);
 			if (err) {
+#ifndef MMAP_LOCK_INITIALIZER
 				up_write(&mm->mmap_sem);
+#else
+                                mmap_write_unlock(mm);
+#endif
 				pinned_pages->nr_pages = 0;
 				goto error_unmap;
 			}
 		}
 
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4,14,0)
+		pinned_pages->nr_pages = get_user_pages_remote(
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,14,0)
+				current,
+#endif
+				mm,
+				(uint64_t)addr,
+				nr_pages,
+				!!(prot & SCIF_PROT_WRITE),
+				pinned_pages->pages,
+				pinned_pages->vma,
+				NULL);
+#else
 		pinned_pages->nr_pages = get_user_pages(
 				current,
 				mm,
@@ -1990,7 +2014,12 @@
 				0,
 				pinned_pages->pages,
 				pinned_pages->vma);
+#endif
+#ifndef MMAP_LOCK_INITIALIZER
 		up_write(&mm->mmap_sem);
+#else
+                mmap_write_unlock(mm);
+#endif
 		if (nr_pages == pinned_pages->nr_pages) {
 #ifdef RMA_DEBUG
 			atomic_long_add_return(nr_pages, &ms_info.rma_pin_cnt);
@@ -2007,7 +2036,11 @@
 				/* Roll back any pinned pages */
 				for (i = 0; i < pinned_pages->nr_pages; i++) {
 					if (pinned_pages->pages[i])
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4,14,0)
+						put_page(pinned_pages->pages[i]);
+#else
 						page_cache_release(pinned_pages->pages[i]);
+#endif
 				}
 				prot &= ~SCIF_PROT_WRITE;
 				try_upgrade = false;
@@ -2436,13 +2469,13 @@
 	int ret;
 	struct reg_range_t *window = pages->cookie;
 	struct endpt *ep = (struct endpt *)window->ep;
-	if (atomic_read(&(&(ep->ref_count))->refcount) > 0) {
+	if (atomic_read((atomic_t *)&(&(ep->ref_count))->refcount) > 0) {
 		kref_get(&(ep->ref_count));
 	} else {
 		WARN_ON(1);
 	}
 	ret = __scif_put_pages(pages);
-	if (atomic_read(&(&(ep->ref_count))->refcount) > 0) {
+	if (atomic_read((atomic_t *)&(&(ep->ref_count))->refcount) > 0) {
 		kref_put(&(ep->ref_count), scif_ref_rel);
 	} else {
 		//WARN_ON(1);
diff -Naur mpss-3.8.6/src/mpss-modules/micscif/micscif_debug.c mpss-modules-3.8.6_el9/micscif/micscif_debug.c
--- mpss-3.8.6/src/mpss-modules/micscif/micscif_debug.c	2019-07-02 04:45:06.000000000 +0800
+++ mpss-modules-3.8.6_el9/micscif/micscif_debug.c	2024-01-03 14:51:57.885283014 +0800
@@ -128,14 +128,21 @@
 {
 	return single_open(file, scif_ep_show, NULL);
 }
-
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5,14,0))
+struct proc_ops scif_ep_fops = {
+        .proc_open           = scif_ep_open,
+        .proc_read           = seq_read,
+        .proc_lseek         = seq_lseek,
+        .proc_release        = single_release,
+};
+#else
 struct file_operations scif_ep_fops = {
 	.open		= scif_ep_open,
 	.read		= seq_read,
 	.llseek		= seq_lseek,
         .release 	= single_release,
 };
-
+#endif
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0))
 
 static int
@@ -230,13 +237,22 @@
 {
 	return single_open(file, scif_rma_window_show, NULL);
 }
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5,14,0))
+struct proc_ops scif_rma_window_fops = {
+        .proc_open           = scif_rma_window_open,
+        .proc_read           = seq_read,
+        .proc_lseek          = seq_lseek,
+        .proc_release        = single_release,
+};
 
+#else
 struct file_operations scif_rma_window_fops = {
 	.open		= scif_rma_window_open,
 	.read		= seq_read,
 	.llseek		= seq_lseek,
         .release 	= single_release,
 };
+#endif
 
 static int
 scif_rma_xfer_show(struct seq_file *m, void *data)
@@ -266,14 +282,21 @@
 {
 	return single_open(file, scif_rma_xfer_show, NULL);
 }
-
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5,14,0))
+struct proc_ops scif_rma_xfer_fops = {
+        .proc_open           = scif_rma_xfer_open,
+        .proc_read           = seq_read,
+        .proc_lseek          = seq_lseek,
+        .proc_release        = single_release,
+};
+#else
 struct file_operations scif_rma_xfer_fops = {
 	.open		= scif_rma_xfer_open,
 	.read		= seq_read,
 	.llseek		= seq_lseek,
         .release 	= single_release,
 };
-
+#endif
 static int
 scif_dev_show(struct seq_file *m, void *data)
 {
@@ -303,14 +326,21 @@
 {
 	return single_open(file, scif_dev_show, NULL);
 }
-
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5,14,0))
+struct proc_ops scif_dev_fops = {
+        .proc_open           = scif_dev_open,
+        .proc_read           = seq_read,
+        .proc_lseek          = seq_lseek,
+        .proc_release        = single_release,
+};
+#else
 struct file_operations scif_dev_fops = {
 	.open		= scif_dev_open,
 	.read		= seq_read,
 	.llseek		= seq_lseek,
         .release 	= single_release,
 };
-
+#endif
 static int
 scif_debug_show(struct seq_file *m, void *data)
 {
@@ -348,14 +378,21 @@
 {
 	return single_open(file, scif_debug_show, NULL);
 }
-
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5,14,0))
+struct proc_ops scif_debug_fops = {
+        .proc_open           = scif_debug_open,
+        .proc_read           = seq_read,
+        .proc_lseek         = seq_lseek,
+        .proc_release        = single_release,
+};
+#else
 struct file_operations scif_debug_fops = {
 	.open		= scif_debug_open,
 	.read		= seq_read,
 	.llseek		= seq_lseek,
         .release 	= single_release,
 };
-
+#endif
 static int
 scif_suspend_show(struct seq_file *m, void *data)
 {
@@ -377,14 +414,21 @@
 {
 	return single_open(file, scif_suspend_show, NULL);
 }
-
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5,14,0))
+struct proc_ops scif_suspend_fops = {
+        .proc_open           = scif_suspend_open,
+        .proc_read           = seq_read,
+        .proc_lseek          = seq_lseek,
+        .proc_release        = single_release,
+};
+#else
 struct file_operations scif_suspend_fops = {
 	.open		= scif_suspend_open,
 	.read		= seq_read,
 	.llseek		= seq_lseek,
         .release 	= single_release,
 };
-
+#endif
 static int
 scif_cache_limit_show(struct seq_file *m, void *data)
 {
@@ -397,14 +441,21 @@
 {
 	return single_open(file, scif_cache_limit_show, NULL);
 }
-
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5,14,0))
+struct proc_ops scif_cache_limit_fops = {
+        .proc_open           = scif_cache_limit_open,
+        .proc_read           = seq_read,
+        .proc_lseek          = seq_lseek,
+        .proc_release        = single_release,
+};
+#else
 struct file_operations scif_cache_limit_fops = {
 	.open		= scif_cache_limit_open,
 	.read		= seq_read,
 	.llseek		= seq_lseek,
         .release 	= single_release,
 };
-
+#endif
 #else // LINUX VERSION 3.10
 
 static int
@@ -792,7 +843,6 @@
 {
 	return single_release(inode, file);
 }
-
 static struct file_operations smpt_file_ops = {
 	.owner   = THIS_MODULE,
 	.open    = smpt_debug_open,
@@ -800,7 +850,6 @@
 	.llseek  = seq_lseek,
 	.release = smpt_debug_release
 };
-
 #ifndef _MIC_SCIF_
 static int log_buf_seq_show(struct seq_file *s, void *pos)
 {
@@ -856,7 +905,6 @@
 {
 	return single_release(inode, file);
 }
-
 static struct file_operations log_buf_ops = {
 	.owner   = THIS_MODULE,
 	.open    = log_buf_open,
diff -Naur mpss-3.8.6/src/mpss-modules/micscif/micscif_nm.c mpss-modules-3.8.6_el9/micscif/micscif_nm.c
--- mpss-3.8.6/src/mpss-modules/micscif/micscif_nm.c	2019-07-02 04:45:06.000000000 +0800
+++ mpss-modules-3.8.6_el9/micscif/micscif_nm.c	2024-01-03 14:51:57.886283006 +0800
@@ -1531,22 +1531,22 @@
 	mic_ctx = get_per_dev_ctx(i - 1);
 
 	switch (mic_ctx->sdbic1) {
-	case SYSTEM_HALT:
-	case SYSTEM_POWER_OFF:
+	case MIC_SYSTEM_HALT:
+	case MIC_SYSTEM_POWER_OFF:
 	{
 		adapter_stop_device(mic_ctx, 1, !RESET_REATTEMPT);
 		wait_for_reset(mic_ctx);
 		mic_ctx->sdbic1 = 0;
 		break;
 	}
-	case SYSTEM_RESTART:
+	case MIC_SYSTEM_RESTART:
 	{
 		mic_setstate(mic_ctx, MIC_LOST);
 		mic_ctx->sdbic1 = 0;
 		break;
 	}
-	case SYSTEM_BOOTING:
-	case SYSTEM_RUNNING:
+	case MIC_SYSTEM_BOOTING:
+	case MIC_SYSTEM_RUNNING:
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0))
 	case SYSTEM_SUSPEND_DISK:
 #endif
diff -Naur mpss-3.8.6/src/mpss-modules/micscif/micscif_rma.c mpss-modules-3.8.6_el9/micscif/micscif_rma.c
--- mpss-3.8.6/src/mpss-modules/micscif/micscif_rma.c	2019-07-02 04:45:06.000000000 +0800
+++ mpss-modules-3.8.6_el9/micscif/micscif_rma.c	2024-01-03 14:51:57.886283006 +0800
@@ -57,22 +57,47 @@
 #ifdef CONFIG_MMU_NOTIFIER
 static void scif_mmu_notifier_release(struct mmu_notifier *mn,
 			struct mm_struct *mm);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,14,0)
 static void scif_mmu_notifier_invalidate_page(struct mmu_notifier *mn,
 				struct mm_struct *mm,
 				unsigned long address);
+#endif
 static void scif_mmu_notifier_invalidate_range_start(struct mmu_notifier *mn,
 				       struct mm_struct *mm,
 				       unsigned long start, unsigned long end);
 static void scif_mmu_notifier_invalidate_range_end(struct mmu_notifier *mn,
 				     struct mm_struct *mm,
 				     unsigned long start, unsigned long end);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,14,0)
+static int scif_mmu_notifier_invalidate_range_start_range(struct mmu_notifier *mn, const struct mmu_notifier_range *range) {
+       scif_mmu_notifier_invalidate_range_start(mn, range->mm, range->start, range->end);
+       return 0;
+}
+static void scif_mmu_notifier_invalidate_range_end_range(struct mmu_notifier *mn, const struct mmu_notifier_range *range) {
+       scif_mmu_notifier_invalidate_range_end(mn, range->mm, range->start, range->end);
+}
+#endif
+
 static const struct mmu_notifier_ops scif_mmu_notifier_ops = {
 	.release = scif_mmu_notifier_release,
 	.clear_flush_young = NULL,
 	.change_pte = NULL,/*TODO*/
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,14,0)
 	.invalidate_page = scif_mmu_notifier_invalidate_page,
+#else
+	/* Kernel 4.13+ no longer has invalidate_page; set all other struct memember explicitly */
+	.clear_young = NULL,
+	.test_young = NULL,
+	.invalidate_range = NULL,
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,14,0)
+        .invalidate_range_start = scif_mmu_notifier_invalidate_range_start_range,
+        .invalidate_range_end = scif_mmu_notifier_invalidate_range_end_range
+#else
 	.invalidate_range_start = scif_mmu_notifier_invalidate_range_start,
-	.invalidate_range_end = scif_mmu_notifier_invalidate_range_end};
+	.invalidate_range_end = scif_mmu_notifier_invalidate_range_end
+#endif
+};
 
 static void scif_mmu_notifier_release(struct mmu_notifier *mn,
 			struct mm_struct *mm)
@@ -86,6 +111,7 @@
 	return;
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,14,0)
 static void scif_mmu_notifier_invalidate_page(struct mmu_notifier *mn,
 				struct mm_struct *mm,
 				unsigned long address)
@@ -98,6 +124,7 @@
 	pr_debug("%s address 0x%lx\n", __func__, address);
 	return;
 }
+#endif
 
 static void scif_mmu_notifier_invalidate_range_start(struct mmu_notifier *mn,
 				       struct mm_struct *mm,
@@ -413,7 +440,11 @@
 				BUG_ON(!page_count(pinned_pages->pages[j]));
 				BUG_ON(atomic_long_sub_return(1, &ms_info.rma_pin_cnt) < 0);
 #endif
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4,14,0)
+				put_page(pinned_pages->pages[j]);
+#else
 				page_cache_release(pinned_pages->pages[j]);
+#endif
 			}
 		}
 	}
@@ -967,8 +998,8 @@
 	{
 		window->unreg_state = OP_IN_PROGRESS;
 		send_msg = true;
-		/* fall through */
 	}
+	FALLTHROUGH;
 	case OP_IN_PROGRESS:
 	{
 		get_window_ref_count(window, 1);
diff -Naur mpss-3.8.6/src/mpss-modules/micscif/micscif_rma_dma.c mpss-modules-3.8.6_el9/micscif/micscif_rma_dma.c
--- mpss-3.8.6/src/mpss-modules/micscif/micscif_rma_dma.c	2019-07-02 04:45:06.000000000 +0800
+++ mpss-modules-3.8.6_el9/micscif/micscif_rma_dma.c	2024-01-03 13:13:01.265730531 +0800
@@ -46,6 +46,11 @@
 #ifndef _MIC_SCIF_
 #include "mic_common.h"
 #endif
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4,14,0)
+#include <linux/nmi.h>
+#endif
+
+static unsigned long timer_fired = 0;
 
 static __always_inline
 void *get_local_va(off_t off, struct reg_range_t *window, size_t len)
@@ -823,10 +828,18 @@
 
 #if !defined(WINDOWS) && !defined(CONFIG_PREEMPT)
 static int softlockup_threshold = 60;
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4,14,0)
+static void avert_softlockup(struct timer_list *t)
+{
+	timer_fired = 1;
+}
+#else
 static void avert_softlockup(unsigned long data)
 {
 	*(unsigned long*)data = 1;
 }
+#endif
 
 /*
  * Add a timer to handle the case of hogging the cpu for
@@ -839,8 +852,13 @@
  */
 static inline void add_softlockup_timer(struct timer_list *timer, unsigned long *data)
 {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4,14,0)
+	timer_setup(timer, avert_softlockup, 0);
+#else
 	setup_timer(timer, avert_softlockup, (unsigned long) data);
+#endif
 	timer->expires = jiffies + usecs_to_jiffies(softlockup_threshold * 1000000 / 3);
+
 	add_timer(timer);
 }
 
@@ -873,7 +891,6 @@
     uint64_t src_start_offset, dst_start_offset;
 	int ret = 0;
 #if !defined(WINDOWS) && !defined(CONFIG_PREEMPT)
-	unsigned long timer_fired = 0;
 	struct timer_list timer;
 	int cpu = smp_processor_id();
 	add_softlockup_timer(&timer, &timer_fired);
diff -Naur mpss-3.8.6/src/mpss-modules/micscif/micscif_select.c mpss-modules-3.8.6_el9/micscif/micscif_select.c
--- mpss-3.8.6/src/mpss-modules/micscif/micscif_select.c	2019-07-02 04:45:06.000000000 +0800
+++ mpss-modules-3.8.6_el9/micscif/micscif_select.c	2024-01-03 14:51:57.886283006 +0800
@@ -50,6 +50,11 @@
 #include <linux/sched/rt.h>
 #endif
 
+#ifndef set_mb
+#define set_mb(var, value)  do { (var) = (value); mb(); } while (0)
+#endif
+#include "micscif_time.h"
+
 struct poll_table_page {
 	struct poll_table_page *next;
 	struct poll_table_entry *entry;
@@ -70,7 +75,7 @@
 
 #define MAX_SLACK	(100 * NSEC_PER_MSEC)
 
-static long __estimate_accuracy(struct timespec *tv)
+static long __estimate_accuracy(TIMESPEC *tv)
 {
 	long slack;
 	int divfactor = 1000;
@@ -93,10 +98,10 @@
 	return slack;
 }
 
-static long estimate_accuracy(struct timespec *tv)
+static long estimate_accuracy(TIMESPEC *tv)
 {
 	unsigned long ret;
-	struct timespec now;
+	TIMESPEC now;
 
 	/*
 	 * Realtime tasks get a slack of 0 for obvious reasons.
@@ -105,8 +110,8 @@
 	if (rt_task(current))
 		return 0;
 
-	ktime_get_ts(&now);
-	now = timespec_sub(*tv, now);
+        KTIME_GET_TS(&now);
+	now = TIMESPEC_SUB(*tv, now);
 	ret = __estimate_accuracy(&now);
 	if (ret < current->timer_slack_ns)
 		return current->timer_slack_ns;
@@ -191,7 +196,11 @@
 	return table->entry++;
 }
 
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(4,14,0))
+static int __pollwake(wait_queue_entry_t *wait, unsigned mode, int sync, void *key)
+#else
 static int __pollwake(wait_queue_t *wait, unsigned mode, int sync, void *key)
+#endif
 {
 	struct poll_wqueues *pwq = wait->private;
 	DECLARE_WAITQUEUE(dummy_wait, pwq->polling_task);
@@ -217,7 +226,11 @@
 	return default_wake_function(&dummy_wait, mode, sync, key);
 }
 
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(4,14,0))
+static int pollwake(wait_queue_entry_t *wait, unsigned mode, int sync, void *key)
+#else
 static int pollwake(wait_queue_t *wait, unsigned mode, int sync, void *key)
+#endif
 {
 	struct poll_table_entry *entry;
 
@@ -315,7 +328,7 @@
 }
 
 static int do_poll(unsigned int nfds,  struct scif_pollepd *ufds,
-		   struct poll_wqueues *wait, struct timespec *end_time)
+		   struct poll_wqueues *wait, TIMESPEC *end_time)
 {
 	poll_table* pt = &wait->pt;
 	ktime_t expire, *to = NULL;
@@ -364,7 +377,7 @@
 		 * pointer to the expiry value.
 		 */
 		if (end_time && !to) {
-			expire = timespec_to_ktime(*end_time);
+			expire = TIMESPEC_TO_KTIME(*end_time);
 			to = &expire;
 		}
 
@@ -375,7 +388,7 @@
 }
 
 static int do_scif_poll(struct scif_pollepd *ufds, unsigned int nfds,
-		struct timespec *end_time)
+		TIMESPEC *end_time)
 {
 	struct poll_wqueues table;
  	int epdcount;
@@ -391,16 +404,16 @@
  * Add two timespec values and do a safety check for overflow.
  * It's assumed that both values are valid (>= 0)
  */
-static struct timespec scif_timespec_add_safe(const struct timespec lhs,
-				  const struct timespec rhs)
+static TIMESPEC scif_timespec_add_safe(const TIMESPEC lhs,
+				  const TIMESPEC rhs)
 {
-	struct timespec res;
+	TIMESPEC res;
 
-	set_normalized_timespec(&res, lhs.tv_sec + rhs.tv_sec,
+	SET_NORMALIZED_TIMESPEC(&res, lhs.tv_sec + rhs.tv_sec,
 				lhs.tv_nsec + rhs.tv_nsec);
 
 	if (res.tv_sec < lhs.tv_sec || res.tv_sec < rhs.tv_sec)
-		res.tv_sec = TIME_T_MAX;
+		res.tv_sec = TIMESPEC_MAX;
 
 	return res;
 }
@@ -415,18 +428,18 @@
  *
  * Returns -EINVAL if sec/nsec are not normalized. Otherwise 0.
  */
-static int scif_poll_select_set_timeout(struct timespec *to, long sec, long nsec)
+static int scif_poll_select_set_timeout(TIMESPEC *to, long sec, long nsec)
 {
-	struct timespec ts = {.tv_sec = sec, .tv_nsec = nsec};
+	TIMESPEC ts = {.tv_sec = sec, .tv_nsec = nsec};
 
-	if (!timespec_valid(&ts))
+	if (!TIMESPEC_VALID(&ts))
 		return -EINVAL;
 
 	/* Optimize for the zero timeout value here */
 	if (!sec && !nsec) {
 		to->tv_sec = to->tv_nsec = 0;
 	} else {
-		ktime_get_ts(to);
+		KTIME_GET_TS(to);
 		*to = scif_timespec_add_safe(*to, ts);
 	}
 	return 0;
@@ -434,7 +447,7 @@
 
 int scif_poll(struct scif_pollepd *ufds, unsigned int nfds, long timeout_msecs)
 {
-	struct timespec end_time, *to = NULL;
+	TIMESPEC end_time, *to = NULL;
 	if (timeout_msecs >= 0) {
 		to = &end_time;
 		scif_poll_select_set_timeout(to, timeout_msecs / MSEC_PER_SEC,
diff -Naur mpss-3.8.6/src/mpss-modules/network-scripts/ifdown mpss-modules-3.8.6_el9/network-scripts/ifdown
--- mpss-3.8.6/src/mpss-modules/network-scripts/ifdown	1970-01-01 08:00:00.000000000 +0800
+++ mpss-modules-3.8.6_el9/network-scripts/ifdown	2024-01-03 13:13:01.288730357 +0800
@@ -0,0 +1,182 @@
+#!/bin/bash
+# Network Interface Configuration System
+# Copyright (c) 1996-2009 Red Hat, Inc. all rights reserved.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License, version 2,
+# as published by the Free Software Foundation.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+
+. /etc/init.d/functions
+. /etc/mpss/network-scripts/network-functions
+. /etc/mpss/network-scripts/network
+
+cd /etc/sysconfig/network-scripts
+
+CONFIG=${1}
+
+[ -z "${CONFIG}" ] && {
+    echo $"Usage: ifdown <configuration>" >&2
+    exit 1
+}
+
+need_config "${CONFIG}"
+
+[ -f "${CONFIG}" ] || {
+    echo $"Usage: ifdown <configuration>" >&2
+    exit 1
+}
+
+source_config
+
+# Check to make sure the device is actually up
+check_device_down ${DEVICE} && [ "$BOOTPROTO" != "dhcp" -a "$BOOTPROTO" != "bootp" ] && [ -n "$VLAN" -a "$VLAN" != "yes" ] && exit 0
+
+if [ -n "${TEAM_MASTER}" ] && [ ! "${DEVICETYPE}" = "TeamPort" ] && [ -x ./ifdown-TeamPort ]; then
+    ./ifdown-TeamPort ${CONFIG} $2
+fi
+
+if [ "${SLAVE}" != "yes" -o -z "${MASTER}" ]; then
+    if [ -n "${HWADDR}" -a -z "${MACADDR}" ]; then
+        FOUNDMACADDR=$(get_hwaddr ${REALDEVICE})
+        if [ -n "${FOUNDMACADDR}" -a "${FOUNDMACADDR}" != "${HWADDR}" ]; then
+            NEWCONFIG=$(get_config_by_hwaddr ${FOUNDMACADDR})
+            if [ -n "${NEWCONFIG}" ]; then
+                eval $(LANG=C grep -F "DEVICE=" $NEWCONFIG)
+            else
+                net_log $"Device ${DEVICE} has MAC address ${FOUNDMACADDR}, instead of configured address ${HWADDR}. Ignoring."
+                exit 1
+            fi
+            if [ -n "${NEWCONFIG}" -a "${NEWCONFIG##*/}" != "${CONFIG##*/}" -a "${DEVICE}" = "${REALDEVICE}" ]; then
+                exec /sbin/ifdown ${NEWCONFIG}
+            else
+                net_log $"Device ${DEVICE} has MAC address ${FOUNDMACADDR}, instead of configured address ${HWADDR}. Ignoring."
+                exit 1
+            fi
+        fi
+    fi
+fi
+
+if is_bonding_device ${DEVICE} ; then
+    for device in $(LANG=C grep -l "^[[:space:]]*MASTER=['\"]\?${DEVICE}['\"]\?\([[:space:]#]\|$\)" /etc/mpss/network-scripts/ifcfg-*) ; do
+        is_ignored_file "$device" && continue
+        /sbin/ifdown ${device##*/}
+    done
+    for arg in $BONDING_OPTS ; do
+        key=${arg%%=*};
+        [[ "${key}" != "arp_ip_target" ]] && continue
+        value=${arg##*=};
+        if [ "${value:0:1}" != "" ]; then
+            OLDIFS=$IFS;
+            IFS=',';
+            for arp_ip in $value; do
+                if grep -q $arp_ip /sys/class/net/${DEVICE}/bonding/arp_ip_target; then
+                    echo "-$arp_ip" > /sys/class/net/${DEVICE}/bonding/arp_ip_target
+                fi
+            done
+            IFS=$OLDIFS;
+        else
+            value=${value#+};
+            if grep -q $value /sys/class/net/${DEVICE}/bonding/arp_ip_target; then
+                echo "-$value" > /sys/class/net/${DEVICE}/bonding/arp_ip_target
+            fi
+        fi
+    done
+fi
+
+#/etc/mpss/network-scripts/ifdown-ipv6 ${CONFIG}
+
+retcode=0
+
+for VER in "" 6 ; do
+    if [ -f "/var/run/dhclient$VER-${DEVICE}.pid" ]; then
+        dhcpid=$(cat /var/run/dhclient$VER-${DEVICE}.pid)
+        generate_lease_file_name $VER
+        if is_true "$DHCPRELEASE";  then
+            /sbin/dhclient -r -lf ${LEASEFILE} -pf /var/run/dhclient$VER-${DEVICE}.pid ${DEVICE} >/dev/null 2>&1
+            retcode=$?
+        else
+            kill $dhcpid >/dev/null 2>&1
+            retcode=$?
+            reason=STOP$VER interface=${DEVICE} /sbin/dhclient-script
+        fi
+        if [ -f "/var/run/dhclient$VER-${DEVICE}.pid" ]; then
+            rm -f /var/run/dhclient$VER-${DEVICE}.pid
+            kill $dhcpid >/dev/null 2>&1
+        fi  
+    fi
+done
+
+# we can't just delete the configured address because that address
+# may have been changed in the config file since the device was
+# brought up.  Flush all addresses associated with this
+# instance instead.
+if [ -d "/sys/class/net/${REALDEVICE}" ]; then
+    LABEL=
+    if [ "${REALDEVICE}" != "${DEVICE}" ]; then
+        LABEL="label ${DEVICE}"
+    fi
+    if [ "${REALDEVICE}" = "lo" ]; then
+        TIMEOUT=""
+        [ -x /usr/bin/timeout ] && TIMEOUT="/usr/bin/timeout --signal=SIGQUIT 4"
+        $TIMEOUT ip addr flush dev ${REALDEVICE} ${LABEL} scope global 2>/dev/null
+        $TIMEOUT ip addr flush dev ${REALDEVICE} ${LABEL} scope host 2>/dev/null
+    else
+        ip addr flush dev ${REALDEVICE} ${LABEL} scope global 2>/dev/null
+        ip -4 addr flush dev ${REALDEVICE} ${LABEL} scope host 2>/dev/null
+    fi
+
+    if [ "${SLAVE}" = "yes" -a -n "${MASTER}" ]; then
+        echo "-${DEVICE}" > /sys/class/net/${MASTER}/bonding/slaves 2>/dev/null
+    fi
+
+    if [ "${REALDEVICE}" = "${DEVICE}" ]; then
+        ip link set dev ${DEVICE} down 2>/dev/null
+    fi
+fi
+[ "$retcode" = "0" ] && retcode=$?
+
+if [ -n "${BRIDGE}" ] && [ -x /usr/sbin/brctl ]; then
+    /sbin/ip link set dev ${DEVICE} down
+    /usr/sbin/brctl delif -- ${BRIDGE} ${DEVICE}
+    # Upon removing a device from a bridge,
+    # it's necessary to make radvd reload its config
+    [ -r /var/run/radvd/radvd.pid ] && kill -HUP $(cat /var/run/radvd/radvd.pid)
+    if [ -d /sys/class/net/${BRIDGE}/brif ] && [ $(ls -1 /sys/class/net/${BRIDGE}/brif | wc -l) -eq 0 ]; then
+        /usr/sbin/brctl delbr -- ${BRIDGE}
+    fi
+fi
+
+if [ "${TYPE}" = "Tap" ]; then
+    TUNMODE="mode tap"
+    [[ ${DEVICE} == tun* ]] && TUNMODE="mode tun"
+    ip tuntap del ${TUNMODE} dev ${DEVICE} >/dev/null
+fi
+
+if [ -n "${TEAM_CONFIG}" ] && [ ! "${DEVICETYPE}" = "Team" ] && [ -x ./ifdown-Team ]; then
+    ./ifdown-Team ${CONFIG} $2
+fi
+
+# wait up to 5 seconds for device to actually come down...
+waited=0
+while ! check_device_down ${DEVICE} && [ "$waited" -lt 50 ] ; do
+    sleep 0.01
+    waited=$(($waited+1))
+done
+
+if [ -n "$VLAN" ]; then
+    # 802.1q VLAN
+    if [ -f /proc/net/vlan/${DEVICE} ]; then
+        ip link delete ${DEVICE} type vlan
+    fi
+fi
+
+exit $retcode
diff -Naur mpss-3.8.6/src/mpss-modules/network-scripts/ifup mpss-modules-3.8.6_el9/network-scripts/ifup
--- mpss-3.8.6/src/mpss-modules/network-scripts/ifup	1970-01-01 08:00:00.000000000 +0800
+++ mpss-modules-3.8.6_el9/network-scripts/ifup	2024-01-03 13:13:01.288730357 +0800
@@ -0,0 +1,383 @@
+#!/bin/bash
+# Network Interface Configuration System
+# Copyright (c) 1996-2014 Red Hat, Inc. all rights reserved.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License, version 2,
+# as published by the Free Software Foundation.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+
+. /etc/init.d/functions
+. /etc/mpss/network-scripts/network-functions
+. /etc/mpss/network-scripts/network
+
+cd /etc/sysconfig/network-scripts
+
+CONFIG=${1}
+
+[ -z "${CONFIG}" ] && {
+    echo $"Usage: ifup <configuration>" >&2
+    exit 1
+}
+
+need_config "${CONFIG}"
+
+source_config
+
+if [ "${BOOTPROTO}" = "bootp" -o "${BOOTPROTO}" = "dhcp" ]; then
+    DYNCONFIG=true
+fi
+
+# load the module associated with that device
+# /sbin/modprobe ${REALDEVICE}
+is_available ${REALDEVICE}
+
+# bail out, if the MAC does not fit
+if [ -n "${HWADDR}" ]; then
+    FOUNDMACADDR=$(get_hwaddr ${REALDEVICE})
+    if [ "${FOUNDMACADDR}" != "${HWADDR}" -a "${FOUNDMACADDR}" != "${MACADDR}" ]; then
+        net_log $"Device ${DEVICE} has different MAC address than expected, ignoring."
+        exit 1
+    fi
+fi
+
+# If the device is a bridge, create it with brctl, if available.
+if [ "${TYPE}" = "Bridge" ]; then
+    if [ ! -x /usr/sbin/brctl ]; then
+        net_log $"Bridge support not available: brctl not found"
+        exit 1
+    fi
+
+    if [ ! -d /sys/class/net/${DEVICE}/bridge ]; then
+        /usr/sbin/brctl addbr -- ${DEVICE} || exit 1
+    fi
+
+    [ -n "${DELAY}" ] && /usr/sbin/brctl setfd -- ${DEVICE} ${DELAY}
+    [ -n "${STP}" ] && /usr/sbin/brctl stp -- ${DEVICE} ${STP}
+    [ -n "${PRIO}" ] && /usr/sbin/brctl setbridgeprio ${DEVICE} ${PRIO}
+    [ -n "${AGEING}" ] && /usr/sbin/brctl setageing ${DEVICE} ${AGEING}
+
+    # add the bits to setup driver parameters here
+    for arg in $BRIDGING_OPTS ; do
+        key=${arg%%=*};
+        value=${arg##*=};
+        if [ "${key}" != "multicast_router" -a "${key}" != "hash_max" -a "${key}" != "multicast_snooping" ]; then
+            echo $value > /sys/class/net/${DEVICE}/bridge/$key
+        fi
+    done
+
+    # set LINKDELAY (used as timeout when calling check_link_down())
+    # to at least (${DELAY} * 2) + 7 if STP is enabled. This is the
+    # minimum time required for /sys/class/net/$REALDEVICE/carrier to
+    # become 1 after "ip link set dev $DEVICE up" is called.
+    if is_true "${STP}"; then
+        if [ -n "${DELAY}" ]; then
+          forward_delay="${DELAY}"
+        else
+          # If the ${DELAY} value is not set by the user, then we need to obtain
+          # the forward_delay value from kernel first, and convert it to seconds.
+          # Otherwise STP might not correctly complete the startup before trying
+          # to obtain an IP address from DHCP.
+          forward_delay="$(cat /sys/devices/virtual/net/${DEVICE}/bridge/forward_delay)"
+          forward_delay="$(convert2sec ${forward_delay} centi)"
+        fi
+
+        forward_delay=$(bc -q <<< "${forward_delay} * 2 + 7")
+
+        # It's possible we are comparing floating point numbers here, therefore
+        # we are using 'bc' for comparison. The [ ] and [[ ]] do not work.
+        (( $(bc -l <<< "${LINKDELAY:-0} < ${forward_delay}") )) && LINKDELAY=${forward_delay}
+
+        unset forward_delay
+    fi
+fi
+
+# Create tap device.
+if [ "${TYPE}" = "Tap" ]; then
+    [ -n "${OWNER}" ] && OWNER="user ${OWNER}"
+    TUNMODE="mode tap"
+    [[ ${DEVICE} == tun* ]] && TUNMODE="mode tun"
+    ip tuntap add ${TUNMODE} ${OWNER} dev ${DEVICE} > /dev/null
+fi
+
+# Team master initialization.
+if [ -n "${TEAM_CONFIG}" ] && [ ! "${DEVICETYPE}" = "Team" ] && [ -x ./ifup-Team ]; then
+    ./ifup-Team ${CONFIG} $2
+fi
+
+if [ -z "${REALDEVICE}" ]; then
+  net_log $"Device name does not seem to be present."
+  exit 1
+fi
+
+# now check the real state
+is_available_wait ${REALDEVICE} ${DEVTIMEOUT} || {
+    if [ -n "$alias" ]; then
+        net_log $"$alias device ${DEVICE} does not seem to be present, delaying initialization."
+    else
+        net_log $"Device ${DEVICE} does not seem to be present, delaying initialization."
+    fi
+    exit 1
+}
+
+
+# this isn't the same as the MAC in the configuration filename.  It is
+# available as a configuration option in the config file, forcing the kernel
+# to think an ethernet card has a different MAC address than it really has.
+if [ -n "${MACADDR}" ]; then
+    ip link set dev ${DEVICE} address ${MACADDR}
+fi
+if [ -n "${MTU}" ]; then
+    ip link set dev ${DEVICE} mtu ${MTU}
+fi
+
+# is the device wireless? If so, configure wireless device specifics
+is_wireless_device ${DEVICE} && . ./ifup-wireless
+
+# Team slave device?
+if [ -n "${TEAM_MASTER}" ] && [ ! "${DEVICETYPE}" = "TeamPort" ] && [ -x ./ifup-TeamPort ]; then
+    ./ifup-TeamPort ${CONFIG} $2
+    ethtool_set
+    exit 0
+fi
+
+# slave device?
+if [ "${SLAVE}" = yes -a "${ISALIAS}" = no -a "${MASTER}" != "" ]; then
+    install_bonding_driver ${MASTER}
+    grep -wq "${DEVICE}" /sys/class/net/${MASTER}/bonding/slaves 2>/dev/null || {
+        /sbin/ip link set dev ${DEVICE} down
+        echo "+${DEVICE}" > /sys/class/net/${MASTER}/bonding/slaves 2>/dev/null
+    }
+    ethtool_set
+
+    exit 0
+fi
+
+# Bonding initialization. For DHCP, we need to enslave the devices early,
+# so it can actually get an IP.
+if [ "$ISALIAS" = no ] && is_bonding_device ${DEVICE} ; then
+    install_bonding_driver ${DEVICE}
+    /sbin/ip link set dev ${DEVICE} up
+    for device in $(LANG=C grep -l "^[[:space:]]*MASTER=['\"]\?${DEVICE}['\"]\?\([[:space:]#]\|$\)" /etc/mpss/network-scripts/ifcfg-*) ; do
+        is_ignored_file "$device" && continue
+        /sbin/ifup ${device##*/} || net_log "Unable to start slave device ${device##*/} for master ${DEVICE}." warning
+    done
+
+    [ -n "${LINKDELAY}" ] && /bin/sleep ${LINKDELAY}
+
+    # add the bits to setup the needed post enslavement parameters
+    for arg in $BONDING_OPTS ; do   
+        key=${arg%%=*};
+        value=${arg##*=};
+        if [ "${key}" = "primary" ]; then 
+            echo $value > /sys/class/net/${DEVICE}/bonding/$key
+        fi
+    done
+fi
+
+# If the device is part of a bridge, add the device to the bridge
+if [ -n "${BRIDGE}" ] && [ -x /usr/sbin/brctl ]; then
+    if [ ! -d /sys/class/net/${BRIDGE}/bridge ]; then
+        /usr/sbin/brctl addbr -- ${BRIDGE} 2>/dev/null
+    fi
+    /sbin/ip addr flush dev ${DEVICE} 2>/dev/null
+    /sbin/ip link set dev ${DEVICE} up
+    ethtool_set
+    [ -n "${LINKDELAY}" ] && /bin/sleep ${LINKDELAY}
+    /usr/sbin/brctl addif -- ${BRIDGE} ${DEVICE}
+    # add the bits to setup driver parameters here
+    for arg in $BRIDGING_OPTS ; do
+        key=${arg%%=*};
+        value=${arg##*=};
+        echo $value > /sys/class/net/${DEVICE}/brport/$key
+    done
+    # Upon adding a device to a bridge,
+    # it's necessary to make radvd reload its config
+    [ -r /var/run/radvd/radvd.pid ] && kill -HUP $(cat /var/run/radvd/radvd.pid)
+    exit 0
+fi
+
+if [ -n "${DYNCONFIG}" ] && [ -x /sbin/dhclient ]; then
+    if is_true "${PERSISTENT_DHCLIENT}"; then
+        ONESHOT="";
+    else
+        ONESHOT="-1";
+    fi;
+    generate_config_file_name
+    generate_lease_file_name
+
+    # Initialize the dhclient args and obtain the hostname options if needed:
+    DHCLIENTARGS="${DHCLIENTARGS} ${ONESHOT} -q ${DHCLIENTCONF} -lf ${LEASEFILE} -pf /var/run/dhclient-${DEVICE}.pid"
+    set_hostname_options DHCLIENTARGS
+
+    echo
+    echo -n $"Determining IP information for ${DEVICE}..."
+    if ! is_true "${PERSISTENT_DHCLIENT}" && check_link_down ${DEVICE}; then
+        echo $" failed; no link present.  Check cable?"
+        exit 1
+    fi
+
+    ethtool_set
+
+    if /sbin/dhclient ${DHCLIENTARGS} ${DEVICE} ; then
+        echo $" done."
+        dhcpipv4="good"
+    else
+        echo $" failed."
+        if is_true "${IPV4_FAILURE_FATAL}"; then
+            exit 1
+        fi
+        if is_false "$IPV6INIT" || ! is_true "$DHCPV6C"; then
+            exit 1
+        fi
+        net_log "Unable to obtain IPv4 DHCP address ${DEVICE}." warning
+    fi
+    # end dynamic device configuration
+else 
+    if [ -z "${IPADDR}" -a -z "${IPADDR0}" -a -z "${IPADDR1}" -a -z "${IPADDR2}" ]; then
+        # enable device without IP, useful for e.g. PPPoE
+        ip link set dev ${REALDEVICE} up
+        ethtool_set
+        [ -n "${LINKDELAY}" ] && /bin/sleep ${LINKDELAY}
+    else
+
+        expand_config
+
+        [ -n "${ARP}" ] && \
+            ip link set dev ${REALDEVICE} $(toggle_value arp $ARP)
+
+        if ! ip link set dev ${REALDEVICE} up ; then
+            net_log $"Failed to bring up ${DEVICE}."
+            exit 1
+        fi
+
+        ethtool_set
+
+        [ -n "${LINKDELAY}" ] && /bin/sleep ${LINKDELAY}
+
+        if [ "${DEVICE}" = "lo" ]; then
+            SCOPE="scope host"
+        else
+            SCOPE=${SCOPE:-}
+        fi
+
+        if [ -n "$SRCADDR" ]; then
+            SRC="src $SRCADDR"
+        else
+            SRC=
+        fi
+
+        # set IP address(es)
+        for idx in {0..256} ; do
+            if [ -z "${ipaddr[$idx]}" ]; then
+                break
+            fi
+
+            if ! LC_ALL=C ip addr ls ${REALDEVICE} | LC_ALL=C grep -q "${ipaddr[$idx]}/${prefix[$idx]}" ; then
+                if [ "${REALDEVICE}" != "lo" ] && [ "${arpcheck[$idx]}" != "no" ] ; then
+                    ARPING=$(/sbin/arping -c 2 -w ${ARPING_WAIT:-3} -D -I ${REALDEVICE} ${ipaddr[$idx]})
+                    if [ $? = 1 ]; then
+                        ARPINGMAC=$(echo $ARPING |  sed -ne 's/.*\[\(.*\)\].*/\1/p')
+                        net_log $"Error, some other host ($ARPINGMAC) already uses address ${ipaddr[$idx]}."
+                        exit 1
+                    fi
+                fi
+
+                if ! ip addr add ${ipaddr[$idx]}/${prefix[$idx]} \
+                    brd ${broadcast[$idx]:-+} dev ${REALDEVICE} ${SCOPE} label ${DEVICE}; then
+                    net_log $"Error adding address ${ipaddr[$idx]} for ${DEVICE}."
+                fi
+            fi
+
+            if [ -n "$SRCADDR" ]; then
+                sysctl -w "net.ipv4.conf.${SYSCTLDEVICE}.arp_filter=1" >/dev/null 2>&1
+            fi
+
+            # update ARP cache of neighboring computers
+            if ! is_false "${arpupdate[$idx]}" && [ "${REALDEVICE}" != "lo" ]; then
+                /sbin/arping -q -A -c 1 -I ${REALDEVICE} ${ipaddr[$idx]}
+                ( sleep 2;
+                /sbin/arping -q -U -c 1 -I ${REALDEVICE} ${ipaddr[$idx]} ) > /dev/null 2>&1 < /dev/null &
+            fi
+
+            # set lifetime of address to forever
+            ip addr change ${ipaddr[$idx]}/${prefix[$idx]} dev ${REALDEVICE} valid_lft forever preferred_lft forever
+        done
+
+        # Set a default route.
+        if [ "${DEFROUTE}" != "no" ] && [ -z "${GATEWAYDEV}" -o "${GATEWAYDEV}" = "${REALDEVICE}" ]; then
+            # set up default gateway. replace if one already exists
+            if [ -n "${GATEWAY}" ] && [ "$(ipcalc --network ${GATEWAY} ${netmask[0]} 2>/dev/null)" = "NETWORK=${NETWORK}" ]; then
+                ip route replace default ${METRIC:+metric $METRIC} \
+                    ${EXTRA_ROUTE_OPTS} \
+                    via ${GATEWAY} ${WINDOW:+window $WINDOW} ${SRC} \
+                    ${GATEWAYDEV:+dev $GATEWAYDEV} ||
+                    net_log $"Error adding default gateway ${GATEWAY} for ${DEVICE}."
+            elif [ "${GATEWAYDEV}" = "${DEVICE}" ]; then
+                ip route replace default ${METRIC:+metric $METRIC} \
+                    ${EXTRA_ROUTE_OPTS} \
+                    ${SRC} ${WINDOW:+window $WINDOW} dev ${REALDEVICE} ||
+                    net_log $"Error adding default gateway for ${REALDEVICE}."
+            fi
+        fi
+    fi
+fi
+
+# Add Zeroconf route.
+if [ -z "${NOZEROCONF}" -a "${ISALIAS}" = "no" -a "${REALDEVICE}" != "lo" ]; then
+    ip route add 169.254.0.0/16 dev ${REALDEVICE} metric $((1000 + $(cat /sys/class/net/${REALDEVICE}/ifindex))) scope link
+fi
+
+if [ "${TYPE}" = "Bridge" ]; then
+    for arg in $BRIDGING_OPTS ; do
+        key=${arg%%=*};
+        value=${arg##*=};
+        if [ "${key}" = "multicast_router" -o "${key}" = "hash_max" -o "${key}" = "multicast_snooping" ]; then
+            echo $value > /sys/class/net/${DEVICE}/bridge/$key
+        fi
+    done
+fi
+
+# IPv6 initialisation?
+#/etc/mpss/network-scripts/ifup-ipv6 ${CONFIG}
+if is_true "${DHCPV6C}" && [ -x /sbin/dhclient ]; then
+
+    # Assign interface into a firewalld zone so we can
+    # obtain the IPv6 via DHCPv6 (empty ZONE means default):
+    if [ "${REALDEVICE}" != "lo" ]; then
+        dbus-send --print-reply --system --dest=org.fedoraproject.FirewallD1 \
+                  /org/fedoraproject/FirewallD1 \
+                  org.fedoraproject.FirewallD1.zone.changeZoneOfInterface \
+                  string:"${ZONE}" string:"${DEVICE}" \
+                  > /dev/null 2>&1
+    fi
+
+    generate_config_file_name 6
+    generate_lease_file_name 6
+    echo
+    echo -n $"Determining IPv6 information for ${DEVICE}..."
+
+    # Initialize the dhclient args for IPv6 and obtain the hostname options if needed:
+    DHCLIENTARGS="-6 -1 ${DHCPV6C_OPTIONS} ${DHCLIENTCONF} -lf ${LEASEFILE} -pf /var/run/dhclient6-${DEVICE}.pid ${DEVICE}"
+    set_hostname_options DHCLIENTARGS
+
+    if /sbin/dhclient $DHCLIENTARGS; then
+        echo $" done."
+    else
+        echo $" failed."
+        if [ "${dhcpipv4}" = "good" -o -n "${IPADDR}" ]; then
+            net_log "Unable to obtain IPv6 DHCP address ${DEVICE}." warning
+        else
+            exit 1
+        fi
+    fi
+fi
+
diff -Naur mpss-3.8.6/src/mpss-modules/network-scripts/network mpss-modules-3.8.6_el9/network-scripts/network
--- mpss-3.8.6/src/mpss-modules/network-scripts/network	1970-01-01 08:00:00.000000000 +0800
+++ mpss-modules-3.8.6_el9/network-scripts/network	2024-01-03 13:13:01.288730357 +0800
@@ -0,0 +1,2 @@
+
+NOZEROCONF=yes
diff -Naur mpss-3.8.6/src/mpss-modules/network-scripts/network-functions mpss-modules-3.8.6_el9/network-scripts/network-functions
--- mpss-3.8.6/src/mpss-modules/network-scripts/network-functions	1970-01-01 08:00:00.000000000 +0800
+++ mpss-modules-3.8.6_el9/network-scripts/network-functions	2024-01-03 13:13:01.288730357 +0800
@@ -0,0 +1,740 @@
+# -*-Shell-script-*-
+#
+# This file is not a stand-alone shell script; it provides functions 
+# to network scripts that source it.
+
+# Set up a default search path.
+PATH="/sbin:/usr/sbin:/bin:/usr/bin"
+export PATH
+
+# We need to initialize the $HOSTNAME variable by ourselves now:
+# (It was previously done for RHEL-6 branch, but got lost in time.)
+HOSTNAME="$(hostname)"
+
+[ -z "$__sed_discard_ignored_files" ] && . /etc/init.d/functions
+
+get_hwaddr ()
+{
+    if [ -f /sys/class/net/${1}/address ]; then
+        tr '[a-z]' '[A-Z]' < /sys/class/net/${1}/address
+    elif [ -d "/sys/class/net/${1}" ]; then
+        LC_ALL= LANG= ip -o link show ${1} 2>/dev/null | \
+            awk '{ print toupper(gensub(/.*link\/[^ ]* ([[:alnum:]:]*).*/,
+                                        "\\1", 1)); }'
+    fi
+}
+
+get_config_by_device ()
+{
+    LANG=C grep -l "^[[:space:]]*DEVICE=['\"]\?${1}['\"]\?\([[:space:]#]\|$\)" \
+        /etc/sysconfig/network-scripts/ifcfg-* \
+        | LC_ALL=C sed -e "$__sed_discard_ignored_files"
+}
+
+get_config_by_hwaddr ()
+{
+    LANG=C grep -il "^[[:space:]]*HWADDR=['\"]\?${1}['\"]\?\([[:space:]#]\|$\)" /etc/sysconfig/network-scripts/ifcfg-* \
+        | LC_ALL=C sed -e "$__sed_discard_ignored_files"
+}
+
+get_config_by_subchannel ()
+{
+    LANG=C grep -E -i -l \
+        "^[[:space:]]*SUBCHANNELS=['\"]?([0-9]\.[0-9]\.[a-f0-9]+,){0,2}${1}(,[0-9]\.[0-9]\.[a-f0-9]+){0,2}['\"]?([[:space:]]+#|[[:space:]]*$)" \
+        /etc/sysconfig/network-scripts/ifcfg-* \
+        | LC_ALL=C sed -e "$__sed_discard_ignored_files"
+}
+
+get_config_by_name ()
+{
+    LANG=C grep -E -i -l "^[[:space:]]*NAME=\"(Auto |System )?${1}\"" \
+        /etc/sysconfig/network-scripts/ifcfg-* \
+        | LC_ALL=C sed -e "$__sed_discard_ignored_files"
+}
+
+get_device_by_hwaddr ()
+{
+    LANG=C ip -o link | awk -F ': ' -vIGNORECASE=1 '!/link\/ieee802\.11/ && /'"$1"'/ { print $2 }'
+}
+
+get_uuid_by_config ()
+{
+    dbus-send --system --print-reply --dest=com.redhat.ifcfgrh1 /com/redhat/ifcfgrh1 com.redhat.ifcfgrh1.GetIfcfgDetails string:"/etc/sysconfig/network-scripts/$1" 2>/dev/null | awk -F '"' '/string / { print $2 }'
+}
+
+generate_lease_file_name ()
+{
+    local ver=$1
+    LEASEFILE="/var/lib/dhclient/dhclient$ver-${DEVICE}.leases"
+    if [ -f $LEASEFILE ]; then
+         return
+    fi
+    LEASEFILE="/var/lib/dhclient/dhclient$ver-${UUID}-${DEVICE}.lease"
+}
+
+generate_config_file_name ()
+{
+    local ver=$1
+    if [ -s /etc/dhcp/dhclient$ver-${DEVICE}.conf ]; then
+        DHCLIENTCONF="-cf /etc/dhcp/dhclient$ver-${DEVICE}.conf";
+    elif [ -s /etc/dhclient$ver-${DEVICE}.conf ]; then
+        DHCLIENTCONF="-cf /etc/dhclient$ver-${DEVICE}.conf";
+    else
+        DHCLIENTCONF='';
+    fi
+}
+
+need_config ()
+{
+    local nconfig
+
+    CONFIG="ifcfg-${1}"
+    [ -f "${CONFIG}" ] && return
+    CONFIG="${1##*/}"
+    [ -f "${CONFIG}" ] && return
+    nconfig=$(get_config_by_name "${1}")
+    if [ -n "$nconfig" ] && [ -f "$nconfig" ]; then
+        CONFIG=${nconfig##*/}
+        return
+    fi
+    local addr=$(get_hwaddr ${1})
+    if [ -n "$addr" ]; then
+        nconfig=$(get_config_by_hwaddr ${addr})
+        if [ -n "$nconfig" ] ; then
+            CONFIG=${nconfig##*/}
+            [ -f "${CONFIG}" ] && return
+        fi
+    fi
+    nconfig=$(get_config_by_device ${1})
+    if [ -n "$nconfig" ] && [ -f "$nconfig" ]; then
+        CONFIG=${nconfig##*/}
+        return
+    fi
+}
+
+source_config ()
+{
+    CONFIG=${CONFIG##*/}
+    DEVNAME=${CONFIG##ifcfg-}
+    . /etc/sysconfig/network-scripts/$CONFIG
+    [ -r "keys-$DEVNAME" ] && . /etc/sysconfig/network-scripts/keys-$DEVNAME
+    case "$TYPE" in
+    Ethernet)
+        DEVICETYPE="eth"
+        ;;
+    CIPE)
+        DEVICETYPE="cipcb"
+        ;;
+    IPSEC)
+        DEVICETYPE="ipsec"
+        ;;
+    Modem)
+        DEVICETYPE="ppp"
+        ;;
+    xDSL)
+        DEVICETYPE="ppp"
+        ;;
+    ISDN)
+        DEVICETYPE="ippp"
+        ;;
+    Wireless)
+        DEVICETYPE="eth"
+        ;;
+    "Token Ring")
+        DEVICETYPE="eth"
+        ;;
+    CTC)
+        DEVICETYPE="ctc"
+        ;;
+    GRE | GRE6 | IPIP | IPIP6)
+        DEVICETYPE="tunnel"
+        ;;
+    SIT | sit)
+        DEVICETYPE="sit"
+        ;;
+    InfiniBand | infiniband)
+        DEVICETYPE="ib"
+        ;;
+    OVS*)
+        DEVICETYPE="ovs"
+        ;;
+    esac
+    if [ -n "$HWADDR" ]; then
+        HWADDR=$(tr '[a-z]' '[A-Z]' <<<"$HWADDR")
+    fi
+    if [ -n "$MACADDR" ]; then
+        MACADDR=$(tr '[a-z]' '[A-Z]' <<<"$MACADDR")
+    fi
+    [ -z "$DEVICE" -a -n "$HWADDR" ] && DEVICE=$(get_device_by_hwaddr $HWADDR)
+    [ -z "$DEVICETYPE" ] && DEVICETYPE=$(echo ${DEVICE} | sed "s/[0-9]*$//")
+    [ -z "$REALDEVICE" -a -n "$PARENTDEVICE" ] && REALDEVICE=$PARENTDEVICE
+    [ -z "$REALDEVICE" ] && REALDEVICE=${DEVICE%%:*}
+    [ -z "$SYSCTLDEVICE" ] && SYSCTLDEVICE=${REALDEVICE/.//}
+    if [ "${DEVICE}" != "${REALDEVICE}" ]; then
+        ISALIAS=yes
+    else
+        ISALIAS=no
+    fi
+    if is_nm_running && [ "$REALDEVICE" != "lo" ] ; then
+        nm_con_load "$CONFIG"
+        if ! is_false $NM_CONTROLLED; then
+            UUID=$(get_uuid_by_config $CONFIG)
+            [ -n "$UUID" ] && _use_nm=true
+        fi
+    fi
+}
+
+nm_con_load () {
+    dbus-send --system --print-reply \
+        --dest=org.freedesktop.NetworkManager \
+        /org/freedesktop/NetworkManager/Settings \
+        org.freedesktop.NetworkManager.Settings.LoadConnections \
+        array:string:"/etc/sysconfig/network-scripts/${1}" >/dev/null 2>&1
+}
+
+ethtool_set()
+{
+    oldifs=$IFS;
+    IFS=';';
+    if [ -n "${ETHTOOL_DELAY}" ]; then
+      # Convert microseconds to seconds:
+      local ETHTOOL_DELAY_SEC=$(convert2sec ${ETHTOOL_DELAY} micro)
+      sleep ${ETHTOOL_DELAY_SEC}
+    fi
+    for opts in $ETHTOOL_OPTS ; do
+        IFS=$oldifs;
+        if [[ "${opts}" =~ [[:space:]]*- ]]; then
+            /sbin/ethtool $opts
+        else
+            /sbin/ethtool -s ${REALDEVICE} $opts
+        fi
+        IFS=';';
+    done
+    IFS=$oldifs;
+}
+
+expand_config ()
+{
+    local i=0 val
+    for idx in '' {0..255} ; do
+        ipaddr[$i]=$(eval echo '$'IPADDR$idx)
+        if [ -z "${ipaddr[$i]}" ]; then
+            [ "$idx" ] && [ $idx -ge 2 ] && break
+            continue
+        fi
+        prefix[$i]=$(eval echo '$'PREFIX$idx)
+        netmask[$i]=$(eval echo '$'NETMASK$idx)
+        broadcast[$i]=$(eval echo '$'BROADCAST$idx)
+        arpcheck[$i]=$(eval echo '$'ARPCHECK$idx)
+        arpupdate[$i]=$(eval echo '$'ARPUPDATE$idx)
+
+        if [ "${prefix[$i]}x" != "x" ]; then
+            val=$(/bin/ipcalc --netmask "${ipaddr[$i]}/${prefix[$i]}")
+            netmask[$i]=${val##NETMASK=}
+        fi
+
+        if [ "${netmask[$i]}x" = "x" ]; then
+            val=$(/bin/ipcalc --netmask "${ipaddr[$i]}")
+            netmask[$i]=${val##NETMASK=}
+        fi
+
+        if [ "${prefix[$i]}x" = "x" ]; then
+            val=$(/bin/ipcalc --prefix ${ipaddr[$i]} ${netmask[$i]})
+            prefix[$i]=${val##PREFIX=}
+        fi
+
+        if [ "${broadcast[$i]}x" = "x" ]; then
+            val=$(/bin/ipcalc --broadcast ${ipaddr[$i]} ${netmask[$i]})
+            broadcast[$i]=${val##BROADCAST=}
+        fi
+
+        if [ "${arpcheck[$i]}x" != "x" ]; then
+            arpcheck[$i]=${arpcheck[$i]##ARPCHECK=}
+            arpcheck[$i]=${arpcheck[$i],,*}
+        fi
+
+        if [ "${arpupdate[$i]}x" != "x" ]; then
+            arpupdate[$i]=${arpupdate[$i]##ARPUPDATE=}
+            arpupdate[$i]=${arpupdate[$i],,*}
+        fi
+
+        i=$((i+1))
+    done
+
+    [ -n "$DHCP_HOSTNAME" ] && DHCP_HOSTNAME=${DHCP_HOSTNAME%%.*}
+
+    if [ -z "${NETWORK}" ]; then
+        eval $(/bin/ipcalc --network ${ipaddr[0]} ${netmask[0]})
+    fi
+}
+
+toggle_value ()
+{
+    if [ "$2" = "yes"    -o "$2" = "YES" ] ; then
+        echo "$1 on"
+    elif [ "$2" = "no"    -o "$2" = "NO" ] ; then
+        echo "$1 off"
+    else
+        echo ''
+    fi
+}
+ 
+do_netreport ()
+{
+    # Notify programs that have requested notification
+    (
+        cd /var/run/netreport || exit
+        for i in * ; do
+            if [ -f $i ]; then
+                if [ "$(id -u)" = "0" ]; then
+                    OWNER=$(stat -c %U $i)
+                    su -s /bin/bash $OWNER -c "kill -SIGIO $i >/dev/null 2>&1 || rm -f $i >/dev/null 2>&1" > /dev/null 2>&1
+                else
+                    kill -SIGIO $i >/dev/null 2>&1 || rm -f $i >/dev/null 2>&1
+                fi
+            fi
+        done
+    )
+}
+
+is_nm_running ()
+{
+    dbus-send --system --print-reply \
+        --dest=org.freedesktop.DBus \
+        /org/freedesktop/DBus \
+        org.freedesktop.DBus.GetNameOwner \
+        string:"org.freedesktop.NetworkManager" >/dev/null 2>&1
+}
+
+is_nm_active ()
+{
+    LANG=C nmcli -t --fields device,state dev status 2>/dev/null | grep -q "^${1}:connected$"
+}
+
+is_nm_handling ()
+{
+    LANG=C nmcli -t --fields device,state dev status 2>/dev/null | grep -q "^\(${1}:connected\)\|\(${1}:connecting.*\)$"
+}
+
+is_nm_device_unmanaged ()
+{
+    LANG=C nmcli -t --fields GENERAL dev show "${1}" 2>/dev/null | awk -F ':' '/GENERAL.STATE/ { if ($2 == "unmanaged") exit 0 ; else exit 1; }'
+}
+
+# Sets $alias to the device module if $? != 0
+is_available ()
+{
+    [ -z "$1" ] && return 1
+
+    [ -d "/sys/class/net/$1" ] && return 0
+
+    [ -n "$BONDING_OPTS" ] && install_bonding_driver $1
+
+    alias=$(modprobe -c | awk \
+        'BEGIN { alias = ""; }
+        $1 == "alias" && $2 == "'"$1"'" { alias = $3; }
+        $1 == "install" { install[$2] = $3; }
+        END {
+            cmd = install[alias];
+            print alias;
+            if (alias == "" || alias == "off" || cmd == "/bin/true" || cmd == ":")
+                exit 1;
+            exit 0;
+        }
+    ')
+    [ $? -eq 0 ] || return 2
+
+    modprobe $1 > /dev/null 2>&1 || {
+        return 1
+    }
+    if [ -n "$HWADDR" ]; then
+        local curdev=$(get_device_by_hwaddr "$HWADDR")
+        if [ -z "$curdev" ]; then
+            return 1
+        fi
+    fi
+
+    if [ ${alias} = "bonding" ]; then
+        install_bonding_driver $1
+    fi
+
+    [ -d "/sys/class/net/$1" ] && return 0 || return 1
+}
+
+is_available_wait ()
+{
+    [ -z "$1" ] && return 1
+
+    local retry=${2##*[!0-9]*}
+
+    is_available $1 && return 0
+    ret=$?
+
+    while [ 0"$retry" -gt 0 ]; do
+        sleep 1
+        [ -d "/sys/class/net/$1" ] && return 0
+        retry=$(($retry -1))
+    done
+
+    return $ret
+}
+
+is_hostname_set ()
+{
+    case "${HOSTNAME}" in
+        '(none)' | 'localhost' | 'localhost.localdomain')
+            # Hostname NOT set:
+            return 1
+            ;;
+        *)
+            # Hostname IS set:
+            return 0
+            ;;
+    esac
+}
+
+need_hostname ()
+{
+    # Should we avoid obtaining hostname from DHCP? (user override)
+    is_true "${NO_DHCP_HOSTNAME}" && return 1
+
+    if is_hostname_set; then
+        # Hostname is already set, we do not need to acquire it:
+        return 1
+    else
+        # Hostname is NOT set, we need to acquire it:
+        return 0
+    fi
+}
+
+set_hostname_options ()
+{
+    # User explicitly requires to *not* send DHCP_HOSTNAME, DHCP_FQDN or HOSTNAME:
+    is_false "${DHCP_SEND_HOSTNAME}" && return
+
+    if [[ -n "${DHCP_HOSTNAME}" && -n "${DHCP_FQDN}" ]]; then
+        net_log $"Both 'DHCP_HOSTNAME=${DHCP_HOSTNAME}' and 'DHCP_FQDN=${DHCP_FQDN}' are configured... Using DHCP_FQDN." warning
+    fi
+
+    local hostname_options=''
+
+    # DHCP_FQDN takes precedence before DHCP_HOSTNAME -- as it does in NetworkManager,
+    # and DHCP_HOSTNAME takes precedence before HOSTNAME:
+    if [[ -n "${DHCP_FQDN}" ]]; then
+        hostname_options="-F ${DHCP_FQDN}"
+    elif [[ -n "${DHCP_HOSTNAME}" ]]; then
+        hostname_options="-H ${DHCP_HOSTNAME}"
+    elif is_hostname_set; then
+        # We need to truncate the hostname in case it is the FQDN:
+        hostname_options="-H ${HOSTNAME%%.*}"
+    else
+        # Nothing to send to the DHCP server:
+        # ['(none)', 'localhost' or 'localhost.localdomain' are not valid]
+        return
+    fi
+
+    # Append the hostname options to the content of passed variable name:
+    eval "$1='${!1} ${hostname_options}'"
+
+    return
+}
+
+set_hostname ()
+{
+    hostname $1
+    if ! grep search /etc/resolv.conf >/dev/null 2>&1; then
+        domain=$(echo $1 | sed 's/^[^\.]*\.//')
+        if [ -n "$domain" ]; then
+            rsctmp=$(mktemp /tmp/XXXXXX);
+            cat /etc/resolv.conf > $rsctmp
+            echo "search $domain" >> $rsctmp
+            change_resolv_conf $rsctmp
+            /bin/rm -f $rsctmp
+        fi    
+    fi
+}
+
+check_device_down ()
+{
+    [ ! -d /sys/class/net/$1 ] && return 0
+    if LC_ALL=C ip -o link show dev $1 2>/dev/null | grep -q ",UP" ; then
+        return 1
+    else
+        return 0
+    fi
+}
+
+check_link_down ()
+{
+    if ! LC_ALL=C ip link show dev $1 2>/dev/null| grep -q ",UP" ; then
+        ip link set dev $1 up >/dev/null 2>&1
+    fi
+    timeout=0
+    delay=10
+    [ -n "$LINKDELAY" ] && delay=$(($LINKDELAY * 2))
+    while [ $timeout -le $delay ]; do
+        [ "$(cat /sys/class/net/$REALDEVICE/carrier 2>/dev/null)" != "0" ] && return 1
+        sleep 0.5
+        timeout=$((timeout+1))
+    done
+    return 0
+}
+
+check_default_route ()
+{
+    LC_ALL=C ip route list match 0.0.0.0/0 | grep -q default
+}
+
+find_gateway_dev ()
+{
+    . /etc/sysconfig/network
+    if [ -n "${GATEWAY}" -a "${GATEWAY}" != "none" ] ; then
+        dev=$(LC_ALL=C /sbin/ip route get to "${GATEWAY}" 2>/dev/null | \
+        sed -n 's/.* dev \([[:alnum:]]*\) .*/\1/p')
+        if [ -n "$dev" ]; then
+            GATEWAYDEV="$dev"
+        fi
+    fi
+}
+
+# After the device $1 goes away, restore the standard default route; typically
+# used for ppp with DEFROUTE temporarily replacing the "standard" default
+# route.
+# FIXME: This function doesn't support some newer features (GATEWAY in ifcfg,
+# $WINDOW, $METRIC)
+add_default_route ()
+{
+    . /etc/sysconfig/network
+    check_default_route && return 0
+    find_gateway_dev
+    if [ "$GATEWAYDEV" != "" -a -n "${GATEWAY}" -a \
+             "${GATEWAY}" != "none" ]; then
+        if ! check_device_down $1; then
+            if [ "$GATEWAY" = "0.0.0.0" ]; then
+                /sbin/ip route add default dev ${GATEWAYDEV}
+            else
+                /sbin/ip route add default via ${GATEWAY}
+            fi
+        fi
+    elif [ -f /etc/default-routes ]; then
+        while read spec; do
+            /sbin/ip route add $spec
+        done < /etc/default-routes
+        rm -f /etc/default-routes
+    fi
+}
+
+is_wireless_device ()
+{
+    [ -x /usr/sbin/iw ] || return 1
+    LC_ALL=C /usr/sbin/iw dev $1 info > /dev/null 2>&1 && return 0
+    return 1
+}
+
+phy_wireless_device ()
+{
+    cat /sys/class/net/$1/phy80211/name
+}
+
+bond_master_exists ()
+{
+    local bond_name
+    [ -z "${1}" ] && return 1
+    [ ! -f /sys/class/net/bonding_masters ] && return 1
+
+    for bond_name in $(< /sys/class/net/bonding_masters); do
+        [ "${bond_name}" == "${1}" ] && return 0
+    done
+    return 1
+}
+
+install_bonding_driver ()
+{
+    local fn="install_bonding_driver"
+
+    if ! bond_master_exists ${1}; then
+        modprobe bonding || return 1
+        echo "+$1" > /sys/class/net/bonding_masters 2>/dev/null
+    fi
+    (
+        # Set config here
+        need_config "$1"
+        source_config
+        if [ -f /sys/class/net/${DEVICE}/bonding/slaves ] && [ $(wc -l < /sys/class/net/${DEVICE}/bonding/slaves) -eq 0 ]; then
+            /sbin/ip link set dev ${DEVICE} down
+
+            # parse options and put them to arrays
+            for arg in $BONDING_OPTS ; do
+                bopts_keys[${#bopts_keys[*]}]=${arg%%=*}
+                bopts_vals[${#bopts_vals[*]}]=${arg##*=}
+            done
+
+            # add the bits to setup driver parameters here
+            # first set mode, miimon
+            for (( idx=0; idx < ${#bopts_keys[*]}; idx++ )) ; do
+                key=${bopts_keys[$idx]}
+                value=${bopts_vals[$idx]}
+
+                if [ "${key}" = "mode" ] ; then
+                    echo "${value}" > /sys/class/net/${DEVICE}/bonding/$key || {
+                        net_log $"Failed to set value '$value' [mode] to ${DEVICE} bonding device" err $fn
+                    }
+                    bopts_keys[$idx]=""
+                fi
+                if [ "${key}" = "miimon" ] ; then
+                    echo "${value}" > /sys/class/net/${DEVICE}/bonding/$key || {
+                        net_log $"Failed to set value '$value' [miimon] to ${DEVICE} bonding device" err $fn
+                    }
+                    bopts_keys[$idx]=""
+                fi
+            done
+
+            # set all other remaining options
+            for (( idx=0; idx < ${#bopts_keys[*]}; idx++ )) ; do
+                key=${bopts_keys[$idx]}
+                value=${bopts_vals[$idx]}
+
+                # option already set; take next
+                [[ -z "$key" ]] && continue
+
+                if [ "${key}" = "arp_ip_target" -a "${value:0:1}" != "+" ]; then
+                    OLDIFS=$IFS;
+                    IFS=',';
+                    for arp_ip in $value; do
+                        if ! grep -q $arp_ip /sys/class/net/${DEVICE}/bonding/$key; then
+                            echo +$arp_ip > /sys/class/net/${DEVICE}/bonding/$key || {
+                                net_log $"Failed to set '$arp_ip' value [arp_ip_target] to ${DEVICE} bonding device" err $fn
+                            }
+                        fi
+                    done
+                    IFS=$OLDIFS;
+                elif [ "${key}" = "arp_ip_target" ]; then
+                    if ! grep -q ${value#+} /sys/class/net/${DEVICE}/bonding/$key; then
+                        echo "$value" > /sys/class/net/${DEVICE}/bonding/$key || {
+                            net_log $"Failed to set '$value' value [arp_ip_target] to ${DEVICE} bonding device" err $fn
+                        }
+                    fi
+                elif [ "${key}" != "primary" ]; then
+                    echo $value > /sys/class/net/${DEVICE}/bonding/$key || {
+                        net_log $"Failed to set '$value' value [$key] to ${DEVICE} bonding device" err $fn
+                    }
+                fi
+            done
+        fi
+    )
+    return 0
+}
+
+is_bonding_device ()
+{
+    [ -f "/sys/class/net/$1/bonding/slaves" ]
+}
+
+# Invoke this when /etc/resolv.conf has changed:
+change_resolv_conf ()
+{
+    s=$(/bin/grep '^[\ \       ]*option' /etc/resolv.conf 2>/dev/null)
+    if [ $# -gt 1 ]; then
+        if [ "x$s" != "x" ]; then
+            s="$s"$'\n'
+        fi
+        n_args=$#
+        while [ $n_args -gt 0 ]; do 
+            case "$s" in
+            *$1*)
+                shift
+                n_args=$(($n_args-1))
+                continue
+                ;;
+            esac
+            s="$s$1"
+            shift
+            if [ $# -gt 0 ]; then
+                s="$s"$'\n'
+            fi
+            n_args=$(($n_args-1))
+        done             
+    elif [ $# -eq 1 ]; then
+        if [ "x$s" != "x" ]; then
+            s="$s"$'\n'$(/bin/grep -vF "$s" $1)
+        else
+            s=$(cat $1)
+        fi
+    fi
+    (echo "$s" > /etc/resolv.conf) >/dev/null 2>&1;
+    r=$?
+    if [ $r -eq 0 ]; then
+        [ -x /sbin/restorecon ] && /sbin/restorecon /etc/resolv.conf >/dev/null 2>&1 # reset the correct context
+        /usr/bin/logger -p local7.notice -t "NET" -i "$0 : updated /etc/resolv.conf"
+        [ -e /var/run/nscd/socket ] && /usr/sbin/nscd -i hosts # invalidate cache
+    fi
+    return $r
+}
+
+# Logging function
+#
+# Usage: net_log <message> <err|warning|info> <optional file/function name>
+#
+# Default level is 'err'.
+
+net_log()
+{
+    local message="$1"
+    local level="$2"
+    local name="$3"
+
+    [ -z "$message" ] && return 1
+    [ -z "$level" ] && level=err
+    [ -z "$name" ] && name=$0
+
+    case $level in
+    'debug')
+        local txt_level=$"DEBUG     "
+        ;;
+    'err')
+        local txt_level=$"ERROR     "
+        ;;
+    'warning')
+        local txt_level=$"WARN      "
+        ;;
+    'info')
+        local txt_level=$"INFO      "
+        ;;
+    esac
+
+    echo "$txt_level: [$name] $message"
+
+    if [ -x /usr/bin/logger ]; then
+        /usr/bin/logger -p daemon.$level -t "$name" "$message"
+    fi
+    return 0
+}
+
+update_DNS_entries()
+{
+    # Remove duplicate values from DNS options if any:
+    if [ -n "${DNS3}" ] && [[ "${DNS3}" == "${DNS2}" || "${DNS3}" == "${DNS1}" ]]; then
+        unset DNS3
+    fi
+
+    if [ -n "${DNS2}" ] && [[ "${DNS2}" == "${DNS1}" ]]; then
+        unset DNS2
+    fi
+
+    # Shift the DNS options if necessary:
+    if [ -z "${DNS1}" ] && [ -n "${DNS2}" ]; then
+        DNS1="${DNS2}"
+        unset DNS2
+    fi
+
+    if [ -z "${DNS2}" ] && [ -n "${DNS3}" ]; then
+        DNS2="${DNS3}"
+        unset DNS3
+    fi
+
+    # We need to check DNS1 again in case only DNS3 was set at all:
+    if [ -z "${DNS1}" ] && [ -n "${DNS2}" ]; then
+        DNS1="${DNS2}"
+        unset DNS2
+    fi
+}
diff -Naur mpss-3.8.6/src/mpss-modules/udev-mic.rules mpss-modules-3.8.6_el9/udev-mic.rules
--- mpss-3.8.6/src/mpss-modules/udev-mic.rules	2019-07-02 04:45:06.000000000 +0800
+++ mpss-modules-3.8.6_el9/udev-mic.rules	2024-01-03 13:13:01.292730327 +0800
@@ -5,5 +5,6 @@
 KERNEL=="scif", ACTION=="add", NAME="mic/%k",MODE="0666", RUN+="/bin/chmod og+x /dev/mic"
 KERNEL=="ctrl", ACTION=="add", NAME="mic/%k", MODE="0666"
 
-# Bring up network interfaces manually on rhel7 after module reload
-KERNEL=="mic*", SUBSYSTEM=="net", RUN+="/bin/sh -c '/bin/grep 7. /etc/redhat-release && /sbin/ifup %k'"
+# Bring up network interfaces manually on rhel8 after module reload
+KERNEL=="mic*", SUBSYSTEM=="net", RUN+="/etc/mpss/network-scripts/ifup %k"
+
diff -Naur mpss-3.8.6/src/mpss-modules/vnet/micveth_dma.c mpss-modules-3.8.6_el9/vnet/micveth_dma.c
--- mpss-3.8.6/src/mpss-modules/vnet/micveth_dma.c	2019-07-02 04:45:06.000000000 +0800
+++ mpss-modules-3.8.6_el9/vnet/micveth_dma.c	2024-01-03 13:13:01.295730304 +0800
@@ -910,7 +910,12 @@
 	.ndo_set_multicast_list = micvnet_multicast_list,
 #endif
 	.ndo_set_mac_address	= micvnet_set_address,
-	.ndo_change_mtu		= micvnet_change_mtu,
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(3,10,0)
+	.ndo_change_mtu_rh74	= micvnet_change_mtu,
+#else
+	.ndo_change_mtu			= micvnet_change_mtu,
+#endif
+
 };
 
 static void
@@ -920,7 +925,11 @@
 
 	/* Initialize the device structure. */
 	dev->netdev_ops = &micvnet_netdev_ops;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(4,14,0)
+    dev->priv_destructor = free_netdev;
+#else
 	dev->destructor = free_netdev;
+#endif
 
 	/* Fill in device structure with ethernet-generic values. */
 	dev->mtu = MICVNET_MAX_MTU;
